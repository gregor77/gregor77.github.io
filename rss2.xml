<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Rhyno Tech Blog</title>
    <link>http://gregor77.github.io/</link>
    
    <atom:link href="http://gregor77.github.io/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>Rhyno Tech Blog about agile, TDD, unit test, web development</description>
    <pubDate>Mon, 26 Dec 2022 15:10:02 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>React에서 Jodit Editor를 사용하여 게시판 만들기</title>
      <link>http://gregor77.github.io/2022/12/26/jodit-editor-spiking/</link>
      <guid>http://gregor77.github.io/2022/12/26/jodit-editor-spiking/</guid>
      <pubDate>Mon, 26 Dec 2022 06:07:42 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;React 개발환경에서 오픈소스 Editor를 활용하여 게시판을 구현을 진행한다.&lt;br&gt;아래 두가지 오픈소스 에디터 중, &lt;strong&gt;Jodit Editor&lt;/strong&gt;를 선택하여 에디터 개발을 진행하기로 결정했다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;</description>
        
      
      
      
      <content:encoded><![CDATA[<p>React 개발환경에서 오픈소스 Editor를 활용하여 게시판을 구현을 진행한다.<br>아래 두가지 오픈소스 에디터 중, <strong>Jodit Editor</strong>를 선택하여 에디터 개발을 진행하기로 결정했다.</p><ul><li><a href="https://github.com/xdan/jodit">Jodit Editor</a><ul><li><a href="https://xdsoft.net/jodit/pro/">라이센스 페이지</a> 참고하여 오픈소스 or Pro버전 사용여부 결정</li></ul></li><li><a href="https://ui.toast.com/tui-editor">TOAST UI Editor</a><ul><li>일부 Tag의 경우 파싱 에러가 발생하여 입력하지 못하도록 넣어줘야 한다는 개발자 경험이 존재</li></ul></li></ul><h2 id="React-Jodit-Editor를-사용한-컴포넌트"><a href="#React-Jodit-Editor를-사용한-컴포넌트" class="headerlink" title="React Jodit Editor를 사용한 컴포넌트"></a>React Jodit Editor를 사용한 컴포넌트</h2><p><a href="https://xdsoft.net/jodit/examples/intergration/react-jodit.html">Jodit에 React 사용법 페이지</a>를 참고하여, Editor 컴포넌트 생성</p><p><img src="/images/jodit-editor/editor-image.png" alt="Jodit Editor 이미지"></p><h2 id="사용자-시나리오"><a href="#사용자-시나리오" class="headerlink" title="사용자 시나리오"></a>사용자 시나리오</h2><ul><li>게시글 목록 조회<ul><li>게시글 목록은 Card view 형태로 목록이 조회된다.</li><li>게시글 내용은 Html tag가 제거된 채로 보여진다.</li></ul></li><li>게시글 생성<ul><li>제목, Editor에서 입력한 내용을 가지고 신규 게시글을 생성한다.</li><li>게시글 id, 제목, 내용을 Elastic Search에 저장한다.</li></ul></li><li>게시글 상세조회<ul><li>제목과 Editor로 등록한 html 내용을 보여준다.</li></ul></li><li>게시글 제목, 내용을 통한 게시글 조회</li></ul><h2 id="개발시-참고"><a href="#개발시-참고" class="headerlink" title="개발시 참고"></a>개발시 참고</h2><h3 id="1-게시글-내용에서-Html-제거"><a href="#1-게시글-내용에서-Html-제거" class="headerlink" title="1. 게시글 내용에서 Html 제거"></a>1. 게시글 내용에서 Html 제거</h3><p>에디터에서 내용을 편집하면 기본적으로 tag가 포함된 내용을 text로 전달받는다.</p><ul><li>Html Tag가 제거된 게시글 내용이 필요한 이유?<ul><li>게시글 목록 조회 시 Card view에서 태그가 제거된 내용 출력</li><li>검색 엔진(Elastic Search)으로 게시글 내용 조회 시, 태그가 제거된 내용을 ES에 저장</li></ul></li></ul><p>처음에는 서버에서 XSS Filter를 통해서 tag를 제거하는 방향으로 접근하려고 했으나, <strong>Jodit Helper 모듈에서 stringTags 함수를 통해서 태그가 제거된 텍스트를 구할 수 있다.</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">handleChange</span> = (<span class="params">htmlContents</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> plaintext = <span class="title class_">Jodit</span>.<span class="property">modules</span>.<span class="property">Helpers</span>.<span class="title function_">stripTags</span>(htmlContents);</span><br><span class="line">    <span class="title function_">onChange</span>(&#123;</span><br><span class="line">      htmlContents,</span><br><span class="line">      <span class="attr">plainContents</span>: plaintext,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">JoditEditor</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      <span class="attr">ref</span>=<span class="string">&#123;editor&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      <span class="attr">value</span>=<span class="string">&#123;content&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      <span class="attr">config</span>=<span class="string">&#123;config&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      <span class="attr">tabIndex</span>=<span class="string">&#123;1&#125;</span> // <span class="attr">tabIndex</span> <span class="attr">of</span> <span class="attr">textarea</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      <span class="attr">onBlur</span>=<span class="string">&#123;(newContent)</span> =&gt;</span> setContent(newContent)&#125; // preferred to use only this option to update the content for performance reasons</span></span><br><span class="line"><span class="language-xml">      onChange=&#123;handleChange&#125;</span></span><br><span class="line"><span class="language-xml">    /&gt;</span></span><br><span class="line">  );</span><br></pre></td></tr></table></figure><p><img src="/images/jodit-editor/cardview-no-html-tags.png" alt="HTML Tag가 제거된 게시글 내용 Demo"></p><h3 id="2-게시글-내용-HTML-출력하기"><a href="#2-게시글-내용-HTML-출력하기" class="headerlink" title="2. 게시글 내용(HTML) 출력하기"></a>2. 게시글 내용(HTML) 출력하기</h3><p>div의 DOM Element에서 innerHtml로 값을 지정하는 경우, 게시글 내용을 표현할 수 있지만 XSS 공격에 쉽게 노출될 수 있기 때문에 위험하다. <strong>React에서는 직접 html을 설정할 수 있지만 위험하다는 것을 상기하기 위해서 dangerouslySetInnerHTML을 통해서 _html 키를 가지는 객체를 전달가능하다.</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div className=<span class="string">&quot;article-detail--contents-wrapper&quot;</span>&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;article-detail--contents&quot;</span> <span class="attr">dangerouslySetInnerHTML</span>=<span class="string">&#123;&#123;</span> <span class="attr">__html:</span> <span class="attr">htmlContents</span> &#125;&#125; /&gt;</span></span></span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p><img src="/images/jodit-editor/editor-detail.png" alt="게시글 상세 내용 Demo"></p><h2 id="마무리"><a href="#마무리" class="headerlink" title="마무리"></a>마무리</h2><p>검색엔진에서 게시글 내용으로 조회하기 위하여, Html tag를 제거한 plainContents를 게시글 id와 함께 Elastic Search에 저장하면 게시글 내용을 통한 검색이 가능할 것으로 예상된다.</p><h2 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h2><ul><li><a href="https://stackoverflow.com/questions/74611717/how-to-show-message-without-html-tags-which-is-take-from-joditeditor">https://stackoverflow.com/questions/74611717/how-to-show-message-without-html-tags-which-is-take-from-joditeditor</a></li><li><a href="https://ko.reactjs.org/docs/dom-elements.html">https://ko.reactjs.org/docs/dom-elements.html</a></li></ul>]]></content:encoded>
      
      
      <category domain="http://gregor77.github.io/categories/React-FE/">React, FE</category>
      
      
      <category domain="http://gregor77.github.io/tags/Jodit-Editor/">Jodit, Editor</category>
      
      
      <comments>http://gregor77.github.io/2022/12/26/jodit-editor-spiking/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>서평 - 인프라 엔지니어의 교과서</title>
      <link>http://gregor77.github.io/2021/06/11/book-review-%EC%9D%B8%ED%94%84%EB%9D%BC%EC%97%94%EC%A7%80%EB%8B%88%EC%96%B4%EC%9D%98%EA%B5%90%EA%B3%BC%EC%84%9C/</link>
      <guid>http://gregor77.github.io/2021/06/11/book-review-%EC%9D%B8%ED%94%84%EB%9D%BC%EC%97%94%EC%A7%80%EB%8B%88%EC%96%B4%EC%9D%98%EA%B5%90%EA%B3%BC%EC%84%9C/</guid>
      <pubDate>Fri, 11 Jun 2021 00:39:56 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;요즘에는 많은 서비스들을 퍼블릭 클라우드에 올려서, 개발자가 서비스 를 운영하기 좋은 상황이다. 그러다 보니 개발자가 고민하고 알아야하는 영역이 점차 확대되었고, 아키텍트와 개발자 역할자 간의 경계가 많이 사라졌다.&lt;br&gt;개발자도 안정적인 서비스</description>
        
      
      
      
      <content:encoded><![CDATA[<p>요즘에는 많은 서비스들을 퍼블릭 클라우드에 올려서, 개발자가 서비스 를 운영하기 좋은 상황이다. 그러다 보니 개발자가 고민하고 알아야하는 영역이 점차 확대되었고, 아키텍트와 개발자 역할자 간의 경계가 많이 사라졌다.<br>개발자도 안정적인 서비스를 운영하기 위해서 고민과 경험을 하는 기회가 많아졌다.</p><p>책의 제목은 **<a href="http://www.kyobobook.co.kr/product/detailViewKor.laf?ejkGb=KOR&mallGb=KOR&barcode=9791165213824&orderClick=LEa&Kc=">인프라 엔지니어의 교과서, 요구사항 분석과 설계</a>**이지만, 독자의 대상을 꼭 인프라 엔지니어로 제한할 필요는 없을 것 같다.<br/><br><strong>소프트웨어 개발자 관점에서 이 책을 읽고 나서 느낀 점을 공유해보겠다.</strong></p><img alt="인프라 엔지니어의 교과서" src="/images/book-review-infra-engineer-book/인프라엔지니어의교과서.PNG" height="50%" width="50%"><h2 id="누가-이-책을-읽으면-좋을까"><a href="#누가-이-책을-읽으면-좋을까" class="headerlink" title="누가 이 책을 읽으면 좋을까?"></a>누가 이 책을 읽으면 좋을까?</h2><h3 id="운영-경험이-없는-개발자"><a href="#운영-경험이-없는-개발자" class="headerlink" title="운영 경험이 없는 개발자"></a>운영 경험이 없는 개발자</h3><p>지금 회사는 개발과 운영 조직이 나누어져 있다. 개발 조직에서 일을 계속 하다보니, 운영 경험이 부족한 상황이다. 최근에 개발한 서비스를 직접 안정적으로 운영해야 하는 상황인데, 안정적인 서비스를 운영하기 위해서 어떤 준비가 필요한지 고민하게 되었다.</p><p>그런 상황에서 이 책을 접하게 되었고, 기존에 경험적으로 조각조각 알고 있었던 내용들을 다시 한번 정리할 수 있었다.<br>특히 개인적으로 책에서 다음 내용이 만족스러웠다. </p><ul><li>가용성을 위한 설계 - 부하분산 클러스터, HA</li><li>성능, 확장성을 위한 설계 - 스케일업, 스케일 아웃</li><li>운영, 유지보수를 위한 설계 - 백업, 모니터링</li></ul><p>물론 이 책은 각 설계에 대한 이론적인 개념을 훑고 지나가는 정도이지, 이런 설계를 위해서 구체적으로 어떤 작업을 해야하는지 세세하게 알려주지는 않는다. 책을 읽어보고 고민해야하는 영역이 어딘지 키워드를 얻을 수 있지만, 그 이후에 구체적인 고민은 독자의 몫이다.</p><h3 id="개발을-이제-시작한-사람들"><a href="#개발을-이제-시작한-사람들" class="headerlink" title="개발을 이제 시작한 사람들"></a>개발을 이제 시작한 사람들</h3><p>개발을 시작하고 몇년 동안을 돌아보면, 구현 관점에서 주로 새로운 방법들을 익히고, 성숙도를 높이는 방법에서만 고민을 했던 것 같다. 그러다보니 내가 개발한 서비스가 유지보수하기 좋고, 안정적으로 서비스를 운영하기 위해서 어떤 작업이 필요한지 까지는 생각이 확장되지 못했다.</p><p>개발하면서 이런 과정이 당연할 수도 있겠지만, 운영에서 어떤 일들이 필요한지 간접적으로라도 알 수 있다면 어플리케이션 영역안에서 개발하면서도 유지보수 하기 좋거나, 안정적인 운영을 위한 소프트웨어 개발을 고민할 수 있을 것 같다.</p><h2 id="책을-읽기-전에-미리-알아둘-것"><a href="#책을-읽기-전에-미리-알아둘-것" class="headerlink" title="책을 읽기 전에 미리 알아둘 것"></a>책을 읽기 전에 미리 알아둘 것</h2><p>요즘은 AWS, Google GCP등 퍼블릭 클라우드에서 서비스 운영을 하는 경우가 많다. <strong>이 책은 퍼블릭 클라우드 기반에서 설명을 하거나 하지 않는다.<br>엔터프라이즈 환경 또는 SI 프로젝트에서 내부에 서버 인프라를 사용하는 환경에서 인프라 엔지니어가 하는 일 위주로 설명이 되어있다.</strong> </p><p>소프트웨어 개발자가 본문에 하드웨어 관점에서 이중화, 확장성을 다루는 내용은 몰입이 떨어질 수 있다. 하지만 내용이 너무 깊게 다루어지거나 이런 것은 아니기 때문에 IT 교양 정보로 알아도 괜찮을 것 같다.</p><h2 id="마무리"><a href="#마무리" class="headerlink" title="마무리"></a>마무리</h2><p>책의 내용이 많은 편이 아니기 때문에 <strong>가볍게 읽을 수 있는 것이 이 책의 가장 큰 장점이다. 인프라 엔지니어 관점에서 안정적인 운영을 위해서 고민해야 하는 관점을 간접적으로 얻을 수 있는 것은 만족스럽다.</strong></p><p>책의 구성이 딱딱한 글만 있는 것이 아니라, 다양한 그림과 이미지를 바탕으로 설명이 되어있어서 이해하기도 쉽고, 자연스럽게 읽히는 것도 좋았다. </p><p>마지막으로 <strong>자체적으로 서버를 구축하여 서비스를 운영하고 있는 팀에서 일하는 개발자</strong>라면 읽어봐도 좋을 것 같다. 운영 경험이 없는 상황에서 운영할 때 어떤 점을 고려해야 하는지 인사이트가 필요한 개발자라면 읽어보는 것을 추천한다.</p>]]></content:encoded>
      
      
      <category domain="http://gregor77.github.io/categories/Review/">Review</category>
      
      
      <category domain="http://gregor77.github.io/tags/%EC%9D%B8%ED%94%84%EB%9D%BC-%EC%97%94%EC%A7%80%EB%8B%88%EC%96%B4%EC%9D%98-%EA%B5%90%EA%B3%BC%EC%84%9C/">인프라 엔지니어의 교과서</category>
      
      <category domain="http://gregor77.github.io/tags/%EC%9A%94%EA%B5%AC%EC%82%AC%ED%95%AD-%EB%B6%84%EC%84%9D%EA%B3%BC-%EC%84%A4%EA%B3%84/">요구사항 분석과 설계</category>
      
      <category domain="http://gregor77.github.io/tags/%EA%B8%B8%EB%B2%97/">길벗</category>
      
      
      <comments>http://gregor77.github.io/2021/06/11/book-review-%EC%9D%B8%ED%94%84%EB%9D%BC%EC%97%94%EC%A7%80%EB%8B%88%EC%96%B4%EC%9D%98%EA%B5%90%EA%B3%BC%EC%84%9C/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Spring Security - 3. 인증 절차를 정의하는 AuthenticationProvider</title>
      <link>http://gregor77.github.io/2021/05/18/spring-security-03/</link>
      <guid>http://gregor77.github.io/2021/05/18/spring-security-03/</guid>
      <pubDate>Tue, 18 May 2021 06:37:17 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;Spring-Security에서-어떻게-인증이-시작될까&quot;&gt;&lt;a href=&quot;#Spring-Security에서-어떻게-인증이-시작될까&quot; class=&quot;headerlink&quot; title=&quot;Spring Security에서 어떻게 인증이 시작될까?&quot;</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="Spring-Security에서-어떻게-인증이-시작될까"><a href="#Spring-Security에서-어떻게-인증이-시작될까" class="headerlink" title="Spring Security에서 어떻게 인증이 시작될까?"></a>Spring Security에서 어떻게 인증이 시작될까?</h1><p>Spring security는 내부에 인증 절차가 이미 구현되어 있다. spring security의 인증 절차를 이해하고 난다면, 구현체와 설정을 통해서 새로운 인증 절차를 추가할 수 있다.</p><p>이번 글을 통해서 아래 내용을 이해하자.</p><ul><li><strong>Spring security 아키텍쳐 기반에서 인증 절차가 어떻게 진행되는가?</strong></li><li><strong>실습을 통해서 커스터마이징된 인증 절차 개발시 어떤 작업을 추가로 해야 하는가?</strong></li></ul><h2 id="1-Spring-security에서-인증절차-이해하기"><a href="#1-Spring-security에서-인증절차-이해하기" class="headerlink" title="1. Spring security에서 인증절차 이해하기"></a>1. Spring security에서 인증절차 이해하기</h2><p><strong>Spring security는 AuthenticationManager(ProviderManager)가 가지고 있는 provider 목록을 순회하면서 provider가 실행 가능한 경우에 provider의 authenticate 메소드를 호출하여 인증 절차를 수행한다.</strong></p><img alt="Spring Security Authentication Architecture" src="/images/spring-security/03/spring-security-authentication-architecture-provider.png" height="80%" width="80%"><h3 id="a-AuthenticationManager"><a href="#a-AuthenticationManager" class="headerlink" title="a. AuthenticationManager"></a>a. AuthenticationManager</h3><p>AutheticationManager는 인증을 처리하는 방법을 정의한 API이다.</p><ul><li>AuthenticationFilter에 의해 AuthenticationManager가 동작한다.</li><li>인증을 처리하면 SecurityContextHolder에 Authentication 값이 세팅된다.</li></ul><h3 id="b-ProviderManager"><a href="#b-ProviderManager" class="headerlink" title="b. ProviderManager"></a>b. ProviderManager</h3><p><strong>ProviderManager는 AuthenticationManager의 가장 일반적인 구현체이다. ProviderManager는 AuthenticationProvider 목록을 위임 받는다.<br>각 AuthenticationProvider는 인증 성공, 실패, 결정할 수 없음을 나타낼 수 있고, 나머지 AuthenticationProvider가 결정을 할 수 있도록 전달한다.</strong></p><p>기본적으로 ProviderManager는 Authentication 성공적인 인증 요청이 반환하는 Authentication 객체에서 민감한 credential 정보를 삭제하려고 시도한다. 이렇게 하면 암호와 같은 정보가 HttpSession에서 오래 지속되는 것을 방지한다.</p><p>이런 방법은 stateless application에서 성능 향상을 위해서 user 객체를 cache에 사용할때 문제가 발생할 수 있다. Authentication에 cache에 있는 개체에 대한 참조가 포함되어 있고, 이 개체의 credential이 제거된 경우, 더 이상 cache 값에 대한 인증할 수 없다.</p><p>따라서 cache를 사용하는 경우 이 문제점을 인지하고, 캐시 구현 또는 반환된 인증 객체를 생성하는 AuthenticaionProvider에서 먼저 객체의 복사본을 만드는 것이다. 또는 ProviderManager의 eraseCredentialsAfterAuthentication 속성을 disable을 적용하라.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// spring-security-core.jar 원본 소스 참고 : ProviderManager 클래스의 authenticate 메소드</span></span><br><span class="line"><span class="keyword">public</span> Authentication <span class="title function_">authenticate</span><span class="params">(Authentication authentication)</span> <span class="keyword">throws</span> AuthenticationException &#123;</span><br><span class="line">    Class&lt;? <span class="keyword">extends</span> <span class="title class_">Authentication</span>&gt; toTest = authentication.getClass();</span><br><span class="line">    <span class="type">AuthenticationException</span> <span class="variable">lastException</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">AuthenticationException</span> <span class="variable">parentException</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">Authentication</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">Authentication</span> <span class="variable">parentResult</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">debug</span> <span class="operator">=</span> logger.isDebugEnabled();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (AuthenticationProvider provider : getProviders()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!provider.supports(toTest)) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (debug) &#123;</span><br><span class="line">            logger.debug(<span class="string">&quot;Authentication attempt using &quot;</span></span><br><span class="line">                    + provider.getClass().getName());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            result = provider.authenticate(authentication);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (result != <span class="literal">null</span>) &#123;</span><br><span class="line">                copyDetails(authentication, result);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (AccountStatusException | InternalAuthenticationServiceException e) &#123;</span><br><span class="line">            prepareException(e, authentication);</span><br><span class="line">            <span class="comment">// SEC-546: Avoid polling additional providers if auth failure is due to</span></span><br><span class="line">            <span class="comment">// invalid account status</span></span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (AuthenticationException e) &#123;</span><br><span class="line">            lastException = e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="c-AuthenticationProvider"><a href="#c-AuthenticationProvider" class="headerlink" title="c. AuthenticationProvider"></a>c. AuthenticationProvider</h3><p><strong>각각의 AuthenticationProvider는 특정 유형의 인증을 수행한다.</strong></p><ul><li>id, password 기반 인증 경우 : username &#x2F; password 가 유효한지 검사</li><li>saml 기반 인증 경우 : saml assertion을 수행 후 authentication 리턴</li></ul><img alt="AuthenticationManager와 AuthenticationProvider" src="/images/spring-security/03/AuthenticationManager.png" height="70%" width="70%"><h2 id="2-실습하기"><a href="#2-실습하기" class="headerlink" title="2. 실습하기"></a>2. 실습하기</h2><p>spring security 구현체에 대해서 알아보았으니, 아래 요건에 해당되는 실습을 해보자. 추후에 커스터마이징한 기능을 만들 상황에 대비해서, 직접 provider, token, filter를 각각 만들어보겠다.<br><br/>(참고 : DB 기반 id&#x2F;password 인증은 spring security의 DaoAuthenticationProvider을 사용하더라도 동작한다.)</p><h3 id="구현체"><a href="#구현체" class="headerlink" title="구현체"></a>구현체</h3><p>실습을 위해서 직접 생성한 구현체들에 prefix로 ‘Custom’을 붙여 네이밍한다.</p><ul><li>CustomAuthenticationProvider<ul><li>id, password 기반 인증</li></ul></li><li>CustomAuthenticationToken<ul><li>email, credentials 포함하는 별도 token 생성</li></ul></li><li>CustomAuthenticationFilter<ul><li>CustomAuthenticationToken을 사용하여 provider의 authenticate 메소드를 호출</li><li>특히, saml 인증 방식 사용하는 경우, 해당 필터에서 saml assertion을 진행 후 인증을 수행하는 provider 호출</li></ul></li><li>WebSecurityConfig<ul><li>custom provider를 AuthenticationManager에 추가하는 설정</li><li>custom filter 설정</li></ul></li></ul><h2 id="a-CustomAuthenticationProvider"><a href="#a-CustomAuthenticationProvider" class="headerlink" title="a. CustomAuthenticationProvider"></a>a. CustomAuthenticationProvider</h2><h4 id="Provider-내부에서-하는일은"><a href="#Provider-내부에서-하는일은" class="headerlink" title="Provider 내부에서 하는일은?"></a><strong>Provider 내부에서 하는일은?</strong></h4><p>provider 내부에서 인증 절차를 수행할 뿐 아니라, 추가적으로 supports 메소드를 통해서 token 타입에 따라서 언제 provider를 사용할지 조건을 지정할 수 있다.<br>실제 클래스명은 의도를 명확하게 하는 의미있는 명으로 naming 하는 것이 좋기 때문에 ‘Custom’ 대신에 프로젝트 keyword를 사용해도 좋다.</p><h4 id="provider-동작-여부"><a href="#provider-동작-여부" class="headerlink" title="provider 동작 여부"></a>provider 동작 여부</h4><p>supports 메소드를 override하여 provider의 동작 여부를 결정할 수 있다. 예제처럼 커스터마이징된 token을 사용하는 경우로 provider 동작조건은 제한함으로써 다른 인증 수행하는 provider에게 영향을 주지 않는다.</p><ul><li>CustomAuthenticationFilter에 attemptAuthentication 메소드 내부에서 token을 사용하여 provider를 호출하는 부분이 선언되어 있다.</li><li>provider의 supports 값이 false를 리턴하면, provider의 authenticate 메소드가 호출되지 않는다. (참고 : ProviderManager 소스)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomAuthenticationProvider</span> <span class="keyword">implements</span> <span class="title class_">AuthenticationProvider</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CustomUserDetailsService userDetailsService;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SamplePasswordEncoder passwordEncoder;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CustomAuthenticationProvider</span><span class="params">(CustomUserDetailsService userDetailsService, SamplePasswordEncoder passwordEncoder)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userDetailsService = userDetailsService;</span><br><span class="line">        <span class="built_in">this</span>.passwordEncoder = passwordEncoder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Authentication <span class="title function_">authenticate</span><span class="params">(Authentication authentication)</span> <span class="keyword">throws</span> AuthenticationException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> authentication.getName();</span><br><span class="line">        <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> (String) authentication.getCredentials();</span><br><span class="line"></span><br><span class="line">        <span class="type">UserDetails</span> <span class="variable">user</span> <span class="operator">=</span> userDetailsService.loadUserByUsername(username);</span><br><span class="line">        <span class="keyword">if</span> (user == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BadCredentialsException</span>(<span class="string">&quot;username is not found. username=&quot;</span> + username);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">this</span>.passwordEncoder.matches(password, user.getPassword())) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BadCredentialsException</span>(<span class="string">&quot;password is not matched&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CustomAuthenticationToken</span>(username, password, user.getAuthorities());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">supports</span><span class="params">(Class&lt;?&gt; authentication)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> CustomAuthenticationToken.class.isAssignableFrom(authentication);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="기본-인증-절차"><a href="#기본-인증-절차" class="headerlink" title="기본 인증 절차"></a>기본 인증 절차</h4><ul><li>16 Line<ul><li><strong>provider 내부에서는 username을 가지고 사용자 정보를 조회</strong> (UserDetailsService 호출)</li><li>실습에서는 username이 email 값이 입력된다. (CustomAuthenticationFilter 참고)</li></ul></li><li>17 ~ 23 Line<ul><li><strong>사용자 정보가 유효한지 판단</strong></li><li>유효하지 않은 경우 (예: 사용자 정보 존재하는지, 계정 잠김, 비밀번호 실패 초과), RuntimeException 발생 (예: BadCredentialException) 후 에러 응답 처리한다.</li><li>id, password 기반 인증이라면, password가 일치하는지</li></ul></li><li>25 Line<ul><li><strong>AuthenticationToken에 사용자 정보(username, authorities)를 세팅한다.</strong></li><li>token 자체가 Authentication 객체이기 때문에, 이후에 SecurityContextHolder 내부 context 객체에 token 값이 저장되어 있다.</li></ul></li></ul><h2 id="b-CustomAuthenticationToken"><a href="#b-CustomAuthenticationToken" class="headerlink" title="b. CustomAuthenticationToken"></a>b. CustomAuthenticationToken</h2><p>spring security에 기본적으로 제공하는 token이 존재한다. (예: AnonymousAuthenticationToken, UsernamePasswordAuthenticationToken)<br><strong>spring security에서 제공하는 token 외에 추가적인 필드들을 가져야하는 경우 별도의 token을 생성해야 한다.</strong> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomAuthenticationToken</span> <span class="keyword">extends</span> <span class="title class_">AbstractAuthenticationToken</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">    <span class="keyword">private</span> String credentials;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CustomAuthenticationToken</span><span class="params">(String email, String credentials, Collection&lt;? extends GrantedAuthority&gt; authorities)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(authorities);</span><br><span class="line">        <span class="built_in">this</span>.email = email;</span><br><span class="line">        <span class="built_in">this</span>.credentials = credentials;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CustomAuthenticationToken</span><span class="params">(Collection&lt;? extends GrantedAuthority&gt; authorities)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(authorities);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getCredentials</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.credentials;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getPrincipal</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.email;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>1 Line<ul><li>AbstractAuthenticationToken을 상속받는 custom token 클래스 생성.</li><li>principal : 사용자를 식별할 수 있는 값 (예: id, email)</li><li>credential : 일반적으로 비밀번호를 의미</li></ul></li><li>인증을 통과하여 생성된 token은 SecurityContextHolder의 context로 부터 얻어올 수 있다.</li></ul><h2 id="c-CustomAuthenticationFilter"><a href="#c-CustomAuthenticationFilter" class="headerlink" title="c. CustomAuthenticationFilter"></a>c. CustomAuthenticationFilter</h2><p>만약 provider의 supports 메소드의 리턴값을 항상 true로 해둔다면, 다른 인증방식을 수행할때도 provider가 동작하게 될 것이다. 따라서 이번 실습은 특정 CustomAuthenticationToken을 사용하는 경우에만 provider가 동작되게 설정했다.</p><p><strong>인증을 수행하기 위한 별도의 provider를 생성했고, provider가 특정 token을 사용하는 경우에만 동작하도록 설정을 했다. 해당 filter에서 custom token을 가지고 provider를 실행하는 부분을 선언한다.</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomAuthenticationFilter</span> <span class="keyword">extends</span> <span class="title class_">AbstractAuthenticationProcessingFilter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CustomAuthenticationFilter</span><span class="params">(RequestMatcher requiresAuthenticationRequestMatcher)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(requiresAuthenticationRequestMatcher);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Authentication <span class="title function_">attemptAuthentication</span><span class="params">(HttpServletRequest request,</span></span><br><span class="line"><span class="params">                                                HttpServletResponse response)</span> <span class="keyword">throws</span> AuthenticationException, IOException, ServletException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">email</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">credentials</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;password&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> getAuthenticationManager().authenticate(<span class="keyword">new</span> <span class="title class_">CustomAuthenticationToken</span>(email, credentials));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>8 Line<ul><li>AbstractAuthenticationProcessingFilter을 상속받아서 attemptAuthentication을 override 한다</li><li>예를 들어 saml 인증방식을 사용하는 경우 saml assertion을 수행 후, 통과하면 id 또는 email로 provider를 통해서 인증을 수행한다.</li></ul></li><li>13 Line <ul><li>custom token을 사용하여 provider를 실행하는 부분을 정의한다.</li></ul></li></ul><h2 id="d-WebSecurityConfig"><a href="#d-WebSecurityConfig" class="headerlink" title="d. WebSecurityConfig"></a>d. WebSecurityConfig</h2><p>WebSecurityConfig는 WebSecurityConfigurerAdapter을 상속받아 <strong>security 관련 설정을 관리</strong>하는 java config 클래스다. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="meta">@EnableGlobalMethodSecurity(prePostEnabled = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebSecurityConfig</span> <span class="keyword">extends</span> <span class="title class_">WebSecurityConfigurerAdapter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> CustomUserDetailsService userDetailsService;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> SamplePasswordEncoder passwordEncoder;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        http</span><br><span class="line">                .csrf().disable()   <span class="comment">//csrf 비활성화하고자 하는 경우</span></span><br><span class="line"><span class="comment">//                .csrf()</span></span><br><span class="line"><span class="comment">//                    .csrfTokenRepository(CookieCsrfTokenRepository.withHttpOnlyFalse())</span></span><br><span class="line"><span class="comment">//                    .and()</span></span><br><span class="line">                .addFilterAfter(customAuthenticationFilter(), CsrfFilter.class)</span><br><span class="line">                .authorizeRequests()</span><br><span class="line">                    .antMatchers(<span class="string">&quot;/&quot;</span>, <span class="string">&quot;home&quot;</span>).permitAll()</span><br><span class="line">                    .anyRequest().authenticated()</span><br><span class="line">                    .and()</span><br><span class="line">                .formLogin()</span><br><span class="line">                    .loginPage(<span class="string">&quot;/login&quot;</span>)</span><br><span class="line">                    .permitAll()</span><br><span class="line">                    .and()</span><br><span class="line">                .logout()</span><br><span class="line">                    .permitAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(AuthenticationManagerBuilder auth)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        auth.authenticationProvider(authenticationProvider());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> CustomAuthenticationFilter <span class="title function_">customAuthenticationFilter</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">CustomAuthenticationFilter</span> <span class="variable">filter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CustomAuthenticationFilter</span>(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">AntPathRequestMatcher</span>(<span class="string">&quot;/api/v1/login&quot;</span>, HttpMethod.POST.name())</span><br><span class="line">        );</span><br><span class="line">        filter.setAuthenticationManager(authenticationManagerBean());</span><br><span class="line">        filter.setAuthenticationSuccessHandler(<span class="keyword">new</span> <span class="title class_">SimpleUrlAuthenticationSuccessHandler</span>(<span class="string">&quot;/hello&quot;</span>));</span><br><span class="line">        filter.setAuthenticationFailureHandler(<span class="keyword">new</span> <span class="title class_">SimpleUrlAuthenticationFailureHandler</span>(<span class="string">&quot;/login?error&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span> filter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> AuthenticationProvider <span class="title function_">authenticationProvider</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CustomAuthenticationProvider</span>(userDetailsService, passwordEncoder);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> AuthenticationManager <span class="title function_">authenticationManagerBean</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.authenticationManagerBean();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>12 Line<ul><li>http 요청에 대한 security 설정</li></ul></li><li>18 Line<ul><li>인증을 위해 생성한 custom filter 적용, .addFilterAfter() 또는 .addFitlerBefore() 메소드를 사용하여 filter 실행 순서를 상대적으로 지정할 수 있다.</li></ul></li><li>32 Line<ul><li>email &#x2F; password 기반 인증을 수행하는 custom provider를 AuthenticationManager에 등록</li></ul></li><li>37 Line<ul><li>custom provider를 사용하여 인증을 진행하는 custom AuthenticationProcessingFilter를 선언하는 부분</li><li>“&#x2F;api&#x2F;v1&#x2F;login” 주소로 POST 요청이 오면 해당 filer 가 동작한다.</li><li>인증이 성공하면 “&#x2F;hello” 화면으로 redirect </li><li>인증이 실패하면 “&#x2F;login?error” 화면으로 redirect</li></ul></li></ul><h2 id="3-동작-확인"><a href="#3-동작-확인" class="headerlink" title="3. 동작 확인"></a>3. 동작 확인</h2><p><a href="https://github.com/gregor77/start-spring-security">start-security 프로젝트</a>에서 resources&#x2F;db&#x2F;data.sql을 참고하면, 테스트 사용자 계정을 확인할 수 있다.</p><ul><li>테스트 계정 1의 id&#x2F;password : <a href="mailto:&#x75;&#115;&#x65;&#x72;&#x31;&#64;&#103;&#x6d;&#97;&#x69;&#x6c;&#46;&#x63;&#111;&#x6d;">&#x75;&#115;&#x65;&#x72;&#x31;&#64;&#103;&#x6d;&#97;&#x69;&#x6c;&#46;&#x63;&#111;&#x6d;</a>&#x2F;1111</li><li>테스트 계정 2의 id&#x2F;password : <a href="mailto:&#117;&#115;&#x65;&#114;&#50;&#x40;&#x67;&#x6d;&#x61;&#105;&#x6c;&#x2e;&#99;&#111;&#x6d;">&#117;&#115;&#x65;&#114;&#50;&#x40;&#x67;&#x6d;&#x61;&#105;&#x6c;&#x2e;&#99;&#111;&#x6d;</a>&#x2F;2222</li><li>adamin 계정의 id&#x2F;password : <a href="mailto:&#97;&#100;&#x6d;&#x69;&#110;&#x40;&#103;&#x6d;&#x61;&#105;&#x6c;&#46;&#99;&#x6f;&#x6d;">&#97;&#100;&#x6d;&#x69;&#110;&#x40;&#103;&#x6d;&#x61;&#105;&#x6c;&#46;&#99;&#x6f;&#x6d;</a>&#x2F;3333</li></ul><h4 id="1-로그인-시도"><a href="#1-로그인-시도" class="headerlink" title="1. 로그인 시도"></a>1. 로그인 시도</h4><ul><li>로그인 화면 주소 : <a href="http://localhost:8080/login">http://localhost:8080/login</a></li><li>서버로 로그인을 위한 “&#x2F;api&#x2F;v1&#x2F;login” 주소로 POST 요청이 날아간다.</li><li>서버에서는 CustomAuthenticationFilter에서 CustomAuthenticationProvider을 통해서 email&#x2F;password 기반 인증을 처리한다.</li></ul><img alt="로그인 페이지" src="/images/spring-security/03/login-page.png" height="30%" width="50%"><h4 id="2-인증-성공시"><a href="#2-인증-성공시" class="headerlink" title="2. 인증 성공시"></a>2. 인증 성공시</h4><ul><li>filter의 successHandler에 따라 “&#x2F;hello” 화면으로 redirect 된다.</li><li>session 정보가 있음을 화면을 통해서 확인 가능하다.</li></ul><img alt="로그인 성공시" src="/images/spring-security/03/login-success.png" height="30%" width="50%"><h4 id="3-인증-실패시"><a href="#3-인증-실패시" class="headerlink" title="3. 인증 실패시"></a>3. 인증 실패시</h4><ul><li>filter의 failureHandler에 따라 “&#x2F;login?error” 주소로 redirect 된다.</li><li>로그인 화면에서 error 문구(“”)가 출력되는 것을 확인 가능하다.</li></ul><img alt="존재하지 않는 사용자(notauser)로 로그인" src="/images/spring-security/03/login-failure-01.png" height="40%" width="50%"><img alt="로그인 실패 문구" src="/images/spring-security/03/login-failure-02.png" height="40%" width="50%"><h2 id="마치며"><a href="#마치며" class="headerlink" title="마치며"></a>마치며</h2><p>이번 글을 통해서 Spring Security에서 어떻게 인증 절차가 시작되고 진행되는지 알아보았다.<br>spring security 기반에서 별도의 인증 절차를 직접 구현하기 위해서,</p><ul><li>AuthenticationFilter</li><li>AuthenticationManager (ProviderManager)</li><li>AuthenticationProvider</li></ul><p>각각의 역할에 대해서 꼭 기억하길 바란다. </p><h2 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h2><ul><li><a href="https://github.com/gregor77/start-spring-security">Rhyno Github 실습 Repository</a></li><li><a href="https://gregor77.github.io/2021/04/19/spring-security-02/">Spring Security - 2. Role과 권한(Privilege)</a></li><li><a href="https://gregor77.github.io/2021/04/19/spring-security-01/">Spring Security - 1. Authentication, SecurityContextHolder</a></li></ul>]]></content:encoded>
      
      
      <category domain="http://gregor77.github.io/categories/Spring-security/">Spring security</category>
      
      
      <category domain="http://gregor77.github.io/tags/Spring-Security/">Spring Security</category>
      
      <category domain="http://gregor77.github.io/tags/%EC%9D%B8%EC%A6%9D-%EC%A0%88%EC%B0%A8/">인증 절차</category>
      
      <category domain="http://gregor77.github.io/tags/AuthenticationManager/">AuthenticationManager</category>
      
      <category domain="http://gregor77.github.io/tags/ProviderManager/">ProviderManager</category>
      
      <category domain="http://gregor77.github.io/tags/AuthenticationProvider/">AuthenticationProvider</category>
      
      
      <comments>http://gregor77.github.io/2021/05/18/spring-security-03/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Spring Security - 2. Role과 권한(Privilege)</title>
      <link>http://gregor77.github.io/2021/04/21/spring-security-02/</link>
      <guid>http://gregor77.github.io/2021/04/21/spring-security-02/</guid>
      <pubDate>Wed, 21 Apr 2021 07:40:17 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;Role과-권한을-조회하는-UserDetailsService&quot;&gt;&lt;a href=&quot;#Role과-권한을-조회하는-UserDetailsService&quot; class=&quot;headerlink&quot; title=&quot;Role과 권한을 조회하는 UserDetails</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="Role과-권한을-조회하는-UserDetailsService"><a href="#Role과-권한을-조회하는-UserDetailsService" class="headerlink" title="Role과 권한을 조회하는 UserDetailsService"></a>Role과 권한을 조회하는 UserDetailsService</h1><p>이번 시간에는 SecurityContext에 보관되는 Authentication, Role과 권한(Authority 또는 Privilege)에 대해 알아보겠다.<br>경험을 바탕으로 Role과 권한의 차이는 무엇이고, 실습 예제로 어떻게 Spring Security에서 GrantedAuthority를 관리하는지 알아보자.</p><p>이번 글을 통해서 아래 내용을 이해하자.</p><ul><li>Spring Security 기반 <strong>Role 과 권한 설계</strong></li><li><strong>사용자 정보를 조회하는 UserDetailsService</strong></li></ul><p>참고로 Spring Security에서 GrantedAuthority와 일반적인 권한을 의미하는 단어로 Authority를 사용하면 단어가 비슷해 혼란을 줄 수 있다고 생각한다.<br>따라서 <strong>이하 본문에서는 권한을 Privilege로 표현하고, GrantedAuthority는 따로 설명을 진행하겠다.</strong></p><h2 id="1-Role과-권한-Privilege-설계"><a href="#1-Role과-권한-Privilege-설계" class="headerlink" title="1. Role과 권한(Privilege) 설계"></a>1. Role과 권한(Privilege) 설계</h2><p>Spring Security에서 Role과 권한(Privilege)을 어떻게 설계해야 된다는 직접적인 가이드는 없다. 기존에 플젝에서 경험을 <a href="https://www.baeldung.com/role-and-privilege-for-spring-security-registration">Spring Security - Roles and Privileges</a> 아티클 기반으로 내용을 정리해본다.</p><h3 id="권한-설계-작업은-언제하는-것이-좋은가"><a href="#권한-설계-작업은-언제하는-것이-좋은가" class="headerlink" title="권한 설계 작업은 언제하는 것이 좋은가?"></a>권한 설계 작업은 언제하는 것이 좋은가?</h3><p>시스템에 따라 어떤 Role이 필요한지는 사용자 시나리오나 Persona 기반으로 도출할 수 있다.<br>하지만 어떤 권한이 필요한지 정의를 할때는 사용자 시나리오나 User Journey Map기반으로 진행하면, 상상을 기반으로 하기때문에 구체적인 상황을 고려하려 설계를 진행하기 어렵다.</p><p><strong>개인적으로 권한(Privilege) 설계는 시스템이 어느 정도 개발이 되고 나서, 실물 기반으로 시스템 권한, 비지니스별 권한 설계하는 것이 구체적인 상황별로 생각을 확장해서 고민할 수 있어서 더 편했던 것 같다.</strong></p><ul><li>장점<ul><li>눈에보이는 구체적인 상황을 기준으로 설계를 진행할 수 있어서 쉽게 작업할 수 있다.</li><li><strong>설계를 실물 기반으로 검증할 수 있어서 불확실성을 줄이고, 불필요한 작업을 할 확률을 줄인다.</strong></li></ul></li><li>단점<ul><li>Role, 권한 설계가 소스, 테스트 포함해서 시스템 전반에 영향을 끼치기 때문에 작업 범위가 커서 시간이 오래 걸릴 수 있다.</li><li>작업 시점이 너무 늦지 않는 것이 중요하다. 작업 시점이 너무 늦으면 권한 설계로 인해 소스가 변경되야 하는 상황이 생기는데, 영향도가 크면 적용하기가 점점 어려워진다.</li></ul></li></ul><h3 id="a-Role"><a href="#a-Role" class="headerlink" title="a. Role"></a>a. Role</h3><p>Role은 시스템에서 사용하는 사용자의 역할을 의미한다. Role은 동시에 두 가지형태로 사용될 수 있다.</p><ol><li><strong>그 자체로 권한으로 사용할 수 있다.</strong></li><li><strong>권한(Privilege)을 담는 Container로써 사용할 수 있다.</strong></li></ol><h3 id="b-권한-Privilege"><a href="#b-권한-Privilege" class="headerlink" title="b. 권한(Privilege)"></a>b. 권한(Privilege)</h3><p>시스템에서 사용하는 low-level의 권한을 의미한다. 앞에서 설명한 것처럼 Role은 권한을 담는 Container로써 역할을 수행할 수 있기 때문에, 권한 설계시에는 Role이 사용할 수 있는 모든 권한이 도출되어 있어야 한다.</p><ul><li>Role과 Privilege 의 관계 : 다대다(N:N)</li><li>권한은 Role별로 그룹핑 되고 관리되는 대상이다. 논리적으로 권한(Privilege 또는 Authoritiy)이 Role보다 더 작고 세밀하다.</li></ul><img alt="Granularity(세밀함) - Role과 GrantedAuthority" src="/images/spring-security/authority_role_granularity.png" height="70%" width="70%"><h3 id="c-Role과-권한-Privilege-설계-예시"><a href="#c-Role과-권한-Privilege-설계-예시" class="headerlink" title="c. Role과 권한(Privilege) 설계 예시"></a>c. Role과 권한(Privilege) 설계 예시</h3><p>이전의 플젝 경험을 바탕으로, Role과 권한 관계를 어떻게 설계할 수 있는지 예를 들어 확인해보자.<br><strong>Role가 권한(Privilege)은 시스템 전반에 영향을 끼치는 high-level 범위에서 설계가 되어야 한다. 사업부 체크와 같은 비지니스별 권한 체크는 여기서 제외하며, 추후에 구체적으로 다루도록 하겠다.</strong> </p><h4 id="“경영지표를-확인하는-대쉬보드-시스템”"><a href="#“경영지표를-확인하는-대쉬보드-시스템”" class="headerlink" title="“경영지표를 확인하는 대쉬보드 시스템”"></a><em>“경영지표를 확인하는 대쉬보드 시스템”</em></h4><p>실적을 조회하는 대쉬보드 형태의 시스템이었고, Role은 일반 사용자와 사용자 관리를 할 수 있는 어드민 사용자로 구분이 되었다.</p><ul><li>ROLE_USER (일반 사용자)<ul><li>READ_AUTHORITY 만 가짐</li></ul></li><li>ROLE_ADMIN (관리자)<ul><li>WRITE_AUTHORITY : 사용자 관리, 메뉴 관리(등록, 수정, 삭제)</li><li>READ_AUTHORITY</li></ul></li></ul><h4 id="“프로젝트의-공정-일감을-관리하는-시스템”"><a href="#“프로젝트의-공정-일감을-관리하는-시스템”" class="headerlink" title="“프로젝트의 공정, 일감을 관리하는 시스템”"></a><em>“프로젝트의 공정, 일감을 관리하는 시스템”</em></h4><p>누구나 사용을 할 수 있지만 회원가입을 한 최초 사용자는 “임시 사용자”로써 프로젝트 공지사항, 메일, 일정등 가장 기본적인 커뮤니케이션 기능만 사용할 수 있다.<br>프로젝트 관리자가 승인을 해주면, “일반 사용자”로 역할이 변경되면서 프로젝트에서 상세한 공정, 일감, 요구사항 관리들의 기능을 수행할 수 있다.<br>프로젝트의 어드민 관리 기능 (예. 메뉴, 사용자, 권한, 캘린더, 회의실)은 “관리자” 역할자만 변경이 가능했다. </p><ul><li>ROLE_TEMPORARY_USER (임시 사용자)<ul><li>최초 회원가입하면 임시 사용자로써, 메일, 일정 관리등 커뮤니케이션 관련된 기능만 기본적으로 사용할 수 있음</li><li>COMMUNICATION_AUTHORITY : 메일 관리, 일정 관리</li></ul></li><li>ROLE_USER (일반 사용자)<ul><li>관리자가 승인을 해주면, 일반 사용자로 변경이 되고 COMMUNICATION_AUTHORITY 외에 추가적으로 공정, 일감 관리 기능까지 수행 가능</li><li>COMMUNICATION_AUTHORITY, WORK_AUTHORITY (공정 관리), TASK_AUTHORITY (일감 관리)</li></ul></li><li>ROLE_ADMIN (관리자)<ul><li>관리자의 경우, 프로젝트가 생성되면 프로젝트 관리자 계정이 자동으로 생성됨</li><li>프로젝트 관리자 계정은 메뉴, 프로젝트 사용자, 권한 관리등 어드민성 기능을 수행할 수 있다.</li><li>기본적으로는 일반 사용자의 권한을 사용할 수 있으며, 추가적으로 설정 관리까지 수행 가능하다.</li><li>CONFIG_AUTHORITY (설정 관리 - 메뉴, 사용자 관리 등등)</li></ul></li></ul><h2 id="2-Spring-Security-실습"><a href="#2-Spring-Security-실습" class="headerlink" title="2. Spring Security 실습"></a>2. Spring Security 실습</h2><p>이전에는 Role과 권한 설계방법에 대해서 알아보았다면, 이제는 Spring Security에서는 Role과 권한 적용을 위해서 어떤 클래스를 사용할 지 알아보자.<br>각 클래스별로 역할이 무엇인지 이해하고 있다면 구현하기 더 수월하다. </p><ul><li>빨간색으로 표시된 부분이 이번 실습과 연관된 클래스이다.</li></ul><p>실습 프로젝트의 구조와 실습과 관련된 클래스에 대해서 알아보자.<br>Role과 권한 설계 예시에서 <strong>“프로젝트의 공정, 일감을 관리하는 시스템”의 내용을 사용하여 Unit Test 기반으로 실습을 진행한다.</strong></p><ul><li>실습 프로젝트 Github 주소 : <a href="https://github.com/gregor77/start-spring-security">https://github.com/gregor77/start-spring-security</a></li><li>Spec : Java 8, Spring Boot, H2, Spring Web, Spring Data JPA, Lombok</li><li>목표 : <strong>Role과 권한 설계 내용을 바탕으로 Spring security에서 사용자의 Role과 권한(Previlege)을 UserDetailsService를 사용해서 조회하는 실습을 진행해보자.</strong></li></ul><h3 id="a-프로젝트-설정"><a href="#a-프로젝트-설정" class="headerlink" title="a. 프로젝트 설정"></a>a. 프로젝트 설정</h3><p>실습 프로젝트는 H2 DB를 사용하여 구동된다.</p><ul><li>resources&#x2F;db&#x2F;data.sql<ul><li>어플리케이션 샘플 데이터(User, Role, Privilege)를 생성하는 insert 쿼리</li><li>사용자 비밀번호는 bcrypt password encoder를 통해서 encoding 된 값이다.</li></ul></li><li>resources&#x2F;db&#x2F;schema.sql<ul><li>어플리케이션을 수행하는데 필요한 테이블 생성 쿼리</li></ul></li><li>resources&#x2F;templates&#x2F;login.html<ul><li>email과 password 기반의 로그인 화면</li></ul></li></ul><h3 id="b-User-Role-Privilege-Entity-객체"><a href="#b-User-Role-Privilege-Entity-객체" class="headerlink" title="b. User, Role, Privilege Entity 객체"></a>b. User, Role, Privilege Entity 객체</h3><ul><li>User<ul><li>사용자 정보를 포함하는 entity 객체로 UserDetails의 구현체이다.</li><li>User와 Role은 N:N 관계이다.</li></ul></li><li>Role<ul><li>시스템에서 관리하는 Role 정보를 저장하는 entity 객체</li><li>Role은 Privilege의 컨테이너로써 역할을 수행하기 때문에 하나의 Role은 여러 개의 권한을 포함한다. </li><li>Role과 Privilege의 관계는 N:N 관계이다.</li><li><strong>Role과 Privilege는 “role_privilege” 매핑 테이블을 통해서 관리된다.</strong></li></ul></li><li>Privilege<ul><li>시스템에서 관리하는 권한 정보를 저장하는 entity 객체</li><li>Role과 Privilege의 관계는 N:N 관계이다.</li></ul></li></ul><h3 id="c-UserDetails"><a href="#c-UserDetails" class="headerlink" title="c. UserDetails"></a>c. UserDetails</h3><ul><li>인증된 핵심 사용자 정보 (권한, 비밀번호, 사용자명, 각종 상태)를 제공하기 위한 interface이다.</li><li>기존에 만들어진 시스템에 존재하는 User 클래스가 UserDetails의 구현체가 되면 된다.</li><li>추가적으로 시스템에서 사용자 관리 시나리오에 따라 isAccountNonExpired, isAccountNonLocked, isCredentialsNonExpired, isEnabled 구현하면 된다.<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">implements</span> <span class="title class_">UserDetails</span> &#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.AUTO)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column</span></span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column</span></span><br><span class="line">    <span class="keyword">private</span> String phoneNumber;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transient</span></span><br><span class="line">    <span class="keyword">private</span> Collection&lt;SimpleGrantedAuthority&gt; authorities;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ManyToMany(fetch = FetchType.EAGER)</span></span><br><span class="line">    <span class="meta">@JoinTable(</span></span><br><span class="line"><span class="meta">            name = &quot;user_role&quot;,</span></span><br><span class="line"><span class="meta">            joinColumns = @JoinColumn(name = &quot;user_id&quot;, referencedColumnName = &quot;id&quot;),</span></span><br><span class="line"><span class="meta">            inverseJoinColumns = @JoinColumn(name = &quot;role_id&quot;, referencedColumnName = &quot;id&quot;)</span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Role&gt; roles;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Collection&lt;? <span class="keyword">extends</span> <span class="title class_">GrantedAuthority</span>&gt; getAuthorities() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.authorities;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getUsername</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAccountNonExpired</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAccountNonLocked</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isCredentialsNonExpired</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEnabled</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="d-UserDetailsService"><a href="#d-UserDetailsService" class="headerlink" title="d. UserDetailsService"></a>d. UserDetailsService</h3><ul><li><strong>username을 가지고 사용자 정보를 조회하고 session에 저장될 사용자 주체 정보인 UserDetails를 반환하는 Interface다.</strong></li><li>각 시스템에서는 커스터마이징을 위한 구현체 클래스를 생성해야 한다.</li><li>[참고] loadUserByUsername()에서 파라미터명을 username이 아니라 email로 변경한 이유는?<ul><li><a href="https://github.com/gregor77/start-spring-security">샘플 프로젝트</a> 로그인 화면에서 email과 password로 로그인하기 때문에, username 파라미터에 email 값으로 호출된다.</li><li>로그인 화면 이동은 샘플 프로젝트 실행 후, 브라우저에서 “<a href="http://localhost:8080/login&quot;">http://localhost:8080/login&quot;</a> 주소로 이동한다.</li></ul></li></ul><img alt="샘플 프로젝트 로그인 화면" src="/images/spring-security/02/login.png" height="50%" width="50%">  <ul><li>loadUserByUsername()에서 하는 일<ul><li>username을 가지고 사용자 정보를 조회</li><li>사용자의 Role과 권한(Privilege)을 조회하여, SimpleGrantedAuthority 목록을 authorities에 세팅한다.</li><li>Authentication 내부 principal 객체에 UserDetails 객체가 저장된다.</li><li>Authentication 내부 authorities 객체에 사용자의 Role과 권한(Privilege) 정보가 저장된다.</li><li><strong>UserDetails에 authorities가 세팅되어 있어야, API별 role이나 권한 체크를 진행할 수 있다.</strong></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomUserDetailsService</span> <span class="keyword">implements</span> <span class="title class_">UserDetailsService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CustomUserDetailsService</span><span class="params">(UserService userService)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userService = userService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> UserDetails <span class="title function_">loadUserByUsername</span><span class="params">(String email)</span> <span class="keyword">throws</span> UsernameNotFoundException &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userService.getUser(email)</span><br><span class="line">                .orElseThrow(() -&gt; <span class="keyword">new</span> <span class="title class_">UsernameNotFoundException</span>(<span class="string">&quot;User is not found. email=&quot;</span> + email));</span><br><span class="line"></span><br><span class="line">        user.setAuthorities(</span><br><span class="line">                Stream.concat(</span><br><span class="line">                        getRoles(user.getRoles()).stream(),</span><br><span class="line">                        getPrivileges(user.getRoles()).stream()</span><br><span class="line">                ).collect(Collectors.toList())</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;SimpleGrantedAuthority&gt; <span class="title function_">getRoles</span><span class="params">(List&lt;Role&gt; roles)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> roles.stream()</span><br><span class="line">                .map(Role::getName)</span><br><span class="line">                .map(SimpleGrantedAuthority::<span class="keyword">new</span>)</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;SimpleGrantedAuthority&gt; <span class="title function_">getPrivileges</span><span class="params">(List&lt;Role&gt; roles)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> roles.stream()</span><br><span class="line">                .flatMap(role -&gt; role.getPrivileges().stream())</span><br><span class="line">                .map(privilege -&gt; <span class="keyword">new</span> <span class="title class_">SimpleGrantedAuthority</span>(privilege.getName()))</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="e-GrantedAuthority"><a href="#e-GrantedAuthority" class="headerlink" title="e. GrantedAuthority"></a>e. GrantedAuthority</h3><ul><li><strong>GrantedAuthority는 ID, Password 기반 인증에서 UserDetailsService를 통해서 조회된다.</strong></li><li><strong>high-level authority라고 부르는 이유는, 어플리케이션 전반에 걸친 권한이기 때문이다. 따라서 특정 도메인에 특화된 권한을 의미하지는 않는다.</strong><ul><li>즉, 시스템 레벨에서 필요한 권한이라고 생각하자.</li><li>만약 specific한 수 천개의 role을 가지고 있었다면, 빠르게 메모리를 사용했을 뿐만 아니라, 사용자 인증을 하는데 많은 시간이 걸렸을 것이다.</li></ul></li><li>도메인 별로 구체적인 권한 체크가 필요한 경우에는, GrantedAuthority로 관리하지 않고, 각 API 별로 비지니스 권한을 체크한다. </li><li>@PreAuthorize나 @Secured 어노테이션을 사용하여 API나 서비스별로 시스템 권한 체크는 할 수 있다.</li><li>Authentication 클래스에 getAuthorities() 메소드를 통하여, 인증받은 사용자의 authorities를 조회할 수 있다.<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Authentication 클래스</span></span><br><span class="line">Collection&lt;? <span class="keyword">extends</span> <span class="title class_">GrantedAuthority</span>&gt; getAuthorities()</span><br></pre></td></tr></table></figure></li></ul><h3 id="f-SecurityContextHolder"><a href="#f-SecurityContextHolder" class="headerlink" title="f. SecurityContextHolder"></a>f. SecurityContextHolder</h3><ul><li>SecurityContext를 보관하는 저장소</li><li>SecurityContext에는 Authentication 인스턴스가 저장된다. </li><li>Authentication에는 principal, credentials, authorities가 저장된다.</li></ul><h3 id="g-CustomUserDetailsServiceTest"><a href="#g-CustomUserDetailsServiceTest" class="headerlink" title="g. CustomUserDetailsServiceTest"></a>g. CustomUserDetailsServiceTest</h3><p>spring test context를 띄워서 샘플 데이터를 대상으로 UserDetailsService가 잘 동작하는지 unit test를 수행한다.<br><strong>각 사용자별로 Role, 권한(Privilege)가 잘 조회되는지 결과값을 확인하는 Assertion 테스트로 작성하였다.</strong></p><ul><li>Role 설명<ul><li>임시 사용자, 일반 사용자, 어드민 사용자 Role로 구성된다.</li><li>피라미드로 생각하면, 아래서부터 위로 임시 사용자 &lt; 일반 사용자 &lt; 관리자 순이다.</li><li>일반 사용자는 임시 사용자 role도 가지기 때문에, 임시 사용자의 권한도 모두 포함한다.</li><li>관리자는 임시 사용자, 일반 사용자 role을 모두 가지기 때문에, 모든 권한을 가진다.</li></ul></li></ul><p>각 사용자별 테스트 검증 내용은 다음과 같다.</p><ul><li>user1<ul><li>임시 사용자(ROLE_TEMPORARY_USER)로써, 의사소통 권한(COMMUNICATION_AUTHORITY)을 가지고 있는지 확인한다.</li></ul></li><li>user2<ul><li>일반 사용자(ROLE_USER)로써 임시 사용자(ROLE_TEMPORARY_USER) Role도 가진다.</li><li>의사소통 권한(COMMUNICATION_AUTHORITY),  공정 관리(WORK_AUTHORITY), 일감 관리(TASK_AUTHORITY) 권한을 가진다.</li></ul></li><li>admin<ul><li>관리자 (ROLE_ADMIN)로써, 일반 사용자, 임시 사용자 Role을 모두 가진다.</li><li>따라서 설정관리 권한(CONFIG_AUTHORITY)을 포함해서 모든 권한을 가진다.</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ExtendWith(SpringExtension.class)</span></span><br><span class="line"><span class="meta">@SpringBootTest(classes = StartSecurityApplication.class)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CustomUserDetailsServiceTest</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">USER1_EMAIL</span> <span class="operator">=</span> <span class="string">&quot;user1@gmail.com&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">USER2_EMAIL</span> <span class="operator">=</span> <span class="string">&quot;user2@gmail.com&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">ADMIN_EMAIL</span> <span class="operator">=</span> <span class="string">&quot;admin@gmail.com&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> CustomUserDetailsService userDetailsService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nested</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">loadUserByUsername</span> &#123;</span><br><span class="line">        <span class="meta">@Test</span></span><br><span class="line">        <span class="meta">@DisplayName(&quot;throw UsernameNotFoundException when user not found with email&quot;)</span></span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">errorCase</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="type">UsernameNotFoundException</span> <span class="variable">error</span> <span class="operator">=</span> assertThrows(UsernameNotFoundException.class,</span><br><span class="line">                    () -&gt; userDetailsService.loadUserByUsername(<span class="string">&quot;not-found@gmail.com&quot;</span>));</span><br><span class="line"></span><br><span class="line">            assertThat(error.getMessage()).isEqualTo(<span class="string">&quot;User is not found. email=not-found@gmail.com&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Test</span></span><br><span class="line">        <span class="meta">@DisplayName(&quot;given user1 is temporary user, when get role, then has temporary_user role and communication authority&quot;)</span></span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">checkAuthorityAsTemporaryUser</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="type">UserDetails</span> <span class="variable">user1</span> <span class="operator">=</span> userDetailsService.loadUserByUsername(USER1_EMAIL);</span><br><span class="line"></span><br><span class="line">            assertThat(user1.getAuthorities())</span><br><span class="line">                    .extracting(GrantedAuthority::getAuthority)</span><br><span class="line">                    .contains(<span class="string">&quot;ROLE_TEMPORARY_USER&quot;</span>, <span class="string">&quot;COMMUNICATION_AUTHORITY&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Test</span></span><br><span class="line">        <span class="meta">@DisplayName(&quot;given user2 is user, when get role, then has communication, user, temporary_user roles, and work, task authorities&quot;)</span></span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">checkAuthorityAsUser</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="type">UserDetails</span> <span class="variable">user2</span> <span class="operator">=</span> userDetailsService.loadUserByUsername(USER2_EMAIL);</span><br><span class="line"></span><br><span class="line">            assertThat(user2.getAuthorities())</span><br><span class="line">                    .extracting(GrantedAuthority::getAuthority)</span><br><span class="line">                    .contains(<span class="string">&quot;ROLE_USER&quot;</span>, <span class="string">&quot;ROLE_TEMPORARY_USER&quot;</span>, <span class="string">&quot;COMMUNICATION_AUTHORITY&quot;</span>, <span class="string">&quot;WORK_AUTHORITY&quot;</span>, <span class="string">&quot;TASK_AUTHORITY&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Test</span></span><br><span class="line">        <span class="meta">@DisplayName(&quot;given admin is admin user, when get role, then has all of roles and authorities&quot;)</span></span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">checkAuthorityAsAdminUser</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="type">UserDetails</span> <span class="variable">admin</span> <span class="operator">=</span> userDetailsService.loadUserByUsername(ADMIN_EMAIL);</span><br><span class="line"></span><br><span class="line">            assertThat(admin.getAuthorities())</span><br><span class="line">                    .extracting(GrantedAuthority::getAuthority)</span><br><span class="line">                    .contains(<span class="string">&quot;ROLE_ADMIN&quot;</span>, <span class="string">&quot;ROLE_USER&quot;</span>, <span class="string">&quot;ROLE_TEMPORARY_USER&quot;</span>, <span class="string">&quot;COMMUNICATION_AUTHORITY&quot;</span>, <span class="string">&quot;WORK_AUTHORITY&quot;</span>, <span class="string">&quot;TASK_AUTHORITY&quot;</span>, <span class="string">&quot;CONFIG_AUTHORITY&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="API-권한-테스트"><a href="#API-권한-테스트" class="headerlink" title="API 권한 테스트"></a>API 권한 테스트</h2><p><a href="https://github.com/gregor77/start-spring-security">샘플 프로젝트</a>을 실행하여 로그인 후, <strong>관리자 권한 사용자(<a href="mailto:&#x61;&#x64;&#109;&#x69;&#110;&#64;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#x63;&#111;&#x6d;">&#x61;&#x64;&#109;&#x69;&#110;&#64;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#x63;&#111;&#x6d;</a>)로 로그인했을때만, 관리자 권한 API가 동작하는 것을 확인할 수 있다.</strong><br>테스트는 Postman을 사용해서 사용자 계정으로 로그인 후, 관리자 권한 API를 호출한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//UserController.java : 사용자 리소스 관리 Controller</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping(value = &quot;/v1/user&quot;)</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserController</span><span class="params">(UserService userService)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userService = userService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(value = &quot;/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="meta">@PreAuthorize(&quot;hasRole(&#x27;ADMIN&#x27;)&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">getUser</span><span class="params">(<span class="meta">@PathVariable</span> <span class="type">long</span> id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> userService.getUser(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping</span></span><br><span class="line">    <span class="meta">@PreAuthorize(&quot;hasRole(&#x27;ADMIN&#x27;)&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseStatus(value = HttpStatus.CREATED)</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">createUser</span><span class="params">(<span class="meta">@RequestBody</span> User user)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!userService.getUser(user.getEmail()).isPresent()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;not found with email=&quot;</span> + user.getEmail());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> userService.createUser(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>API 권한체크 설명</p><ul><li>API에서 @PreAuthorize 어노테이션을 사용해서 Role 체크를 수행하고 있다.</li><li><strong>@PreAuthorize 어노테이션 내부에서 “hasRole” security expression을 사용하여 관리자(ROLE_ADMIN) 권한을 체크하고 있다.</strong></li><li><strong>hasRole 내부에서 defaultRolePrefix 가 “ROLE_”을 붙여서 검사하기 때문에, hasRole 문법의 인자에는 순수하게 Role명만 입력하면 된다.</strong></li></ul></li><li><p>관리자 권한 API</p><ul><li>사용자 조회 API : GET, &#x2F;v1&#x2F;user&#x2F;{id} </li><li>사용자 등록 API : POST, &#x2F;v1&#x2F;user</li></ul></li><li><p>실패 사용자 계정</p><ul><li>임시 사용자 권한 : <a href="mailto:&#x75;&#115;&#101;&#114;&#x31;&#x40;&#x67;&#109;&#x61;&#x69;&#108;&#46;&#99;&#111;&#109;">&#x75;&#115;&#101;&#114;&#x31;&#x40;&#x67;&#109;&#x61;&#x69;&#108;&#46;&#99;&#111;&#109;</a> &#x2F; 1111</li><li>일반 사용자 권한 : <a href="mailto:&#117;&#115;&#101;&#x72;&#50;&#64;&#x67;&#x6d;&#x61;&#105;&#108;&#46;&#99;&#111;&#109;">&#117;&#115;&#101;&#x72;&#50;&#64;&#x67;&#x6d;&#x61;&#105;&#108;&#46;&#99;&#111;&#109;</a> &#x2F; 2222</li></ul></li><li><p>성공 사용자 계정</p><ul><li>관리자 권한 : <a href="mailto:&#97;&#100;&#109;&#x69;&#110;&#64;&#103;&#109;&#97;&#x69;&#108;&#x2e;&#x63;&#x6f;&#109;">&#97;&#100;&#109;&#x69;&#110;&#64;&#103;&#109;&#97;&#x69;&#108;&#x2e;&#x63;&#x6f;&#109;</a>  &#x2F; 3333</li></ul></li></ul><img alt="1. 어드민 계정 로그인" src="/images/spring-security/02/api-test-admin-login.png" height="70%" width="70%"><img alt="2. (성공) 어드민 권한 사용자 조회 API 테스트" src="/images/spring-security/02/api-test-admin-authority.png" height="70%" width="70%"><img alt="3. (실패) 일반사용자 권한 사용자 조회 API 테스트" src="/images/spring-security/02/api-test-not-authority.png" height="70%" width="70%"><h2 id="마무리"><a href="#마무리" class="headerlink" title="마무리"></a>마무리</h2><p>이번 시간에 인증된 사용자 정보를 가리키는 UserDetails 인터페이스와 사용자 정보를 조회하는 UserDetailsService를 구현해 보았다.<br>그리고 인증된 사용자 정보가 SecurityContext 내부에 Authentication 객체에 저장되는 것을 확인할 수 있었다.</p><p>또한 사용자 인증 후, Authentication에 세팅된 authorities를 기반으로, @PreAuthorize 어노테이션에 선언된 API 권한 체크까지 정상적으로 동작하는 것을 확인할 수 있었다.</p><p>마지막으로 이번 블로그 포스트를 통해서 아래 내용은 꼭 이해하고 갔으면 한다.</p><ul><li><strong>Spring security 아키텍쳐에서 UserDetails, UserDetailsService에 대한 역할</strong></li><li><strong>시스템에서 사용하는 사용자의 Role과 권한(Previlege) 설계 방법</strong></li><li>UserDetails에 Role과 권한(Previlege)을 GrantedAuthority로 세팅하는 방법</li></ul><h2 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h2><ul><li><a href="https://github.com/gregor77/start-spring-security">Rhyno Github 실습 Repository</a></li><li><a href="https://www.baeldung.com/role-and-privilege-for-spring-security-registration">Spring Security - Roles and Privileges</a></li><li><a href="https://gregor77.github.io/2021/04/19/spring-security-01/">Spring Security - 1. Authentication, SecurityContextHolder</a></li></ul>]]></content:encoded>
      
      
      <category domain="http://gregor77.github.io/categories/Spring-security/">Spring security</category>
      
      
      <category domain="http://gregor77.github.io/tags/Spring-Security/">Spring Security</category>
      
      <category domain="http://gregor77.github.io/tags/Authentication/">Authentication</category>
      
      <category domain="http://gregor77.github.io/tags/UserDetailsService/">UserDetailsService</category>
      
      <category domain="http://gregor77.github.io/tags/Role/">Role</category>
      
      <category domain="http://gregor77.github.io/tags/GrantedAuthority/">GrantedAuthority</category>
      
      <category domain="http://gregor77.github.io/tags/Privilege/">Privilege</category>
      
      
      <comments>http://gregor77.github.io/2021/04/21/spring-security-02/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Spring Security - 1. Authentication, SecurityContextHolder</title>
      <link>http://gregor77.github.io/2021/04/19/spring-security-01/</link>
      <guid>http://gregor77.github.io/2021/04/19/spring-security-01/</guid>
      <pubDate>Mon, 19 Apr 2021 14:58:10 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;Authentication과-SecurityContextHolder&quot;&gt;&lt;a href=&quot;#Authentication과-SecurityContextHolder&quot; class=&quot;headerlink&quot; title=&quot;Authentication과 Se</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="Authentication과-SecurityContextHolder"><a href="#Authentication과-SecurityContextHolder" class="headerlink" title="Authentication과 SecurityContextHolder"></a>Authentication과 SecurityContextHolder</h1><p>Spring Security document를 보면서 SecurityContextHolder에 대해서 알아본다.<br>Unit Test 기반으로 document에 설명되어 있는 내용을 직접 확인해보자.<br>Spring Security 인증 모델에서 핵심은 <strong>SecurityContextHolder</strong>이다. </p><h2 id="Authentication"><a href="#Authentication" class="headerlink" title="Authentication"></a>Authentication</h2><p><strong>Session에 저장되는 정보가 Authentication이라 생각하면 된다. Authentication은 역할에 따라서 principal, credentials, authorities, details로 구성된다.</strong><br>Authentication은 SecurityContextHolder 내부에 보관되는 SecurityContext에 저장된다.</p><ul><li>Principal<ul><li>식별된 사용자 정보를 보관한다. UserDetails의 인스턴스이다.</li><li>시스템에 따라 UserDetails 클래스를 상속하여, 커스텀한 형태로 유지할 수 있다.</li></ul></li><li>Credentials<ul><li>주체 (사용자)가 올바르다는 것을 증명하는 자격 증명이다.</li><li>보통 비밀번호를 의미하며, AuthenticationManager와 관련된 항목일 수 있다.</li></ul></li><li>Authorities<ul><li>AuthenticationManager가 설정한 권한을 의미</li><li>Authentication 상태에 영향을 주지 않거나 수정할 수 없는 인스턴스를 사용해야 한다.</li></ul></li></ul><h2 id="SecurityContextHolder"><a href="#SecurityContextHolder" class="headerlink" title="SecurityContextHolder"></a>SecurityContextHolder</h2><p><img src="/images/spring-security/securitycontextholder.png" alt="spring security context holder"></p><ul><li>인증된 사용자의 구체적인 정보를 보관한다.</li><li>Spring security는 SecurityContextHolder가 어떻게 만들어지는지에 대해서는 신경쓰지 않는다.</li><li>만약 값을 포함하고 있다면, 현재 인증된 사용자 정보로 사용된다.</li><li>사용자가 인증되었음을 나타내는 가장 간단한 방법은 SecurityContextHolder를 직접 설정하는 것이다.</li></ul><h3 id="Test-1-SecurityContextHolder-세팅-및-조회"><a href="#Test-1-SecurityContextHolder-세팅-및-조회" class="headerlink" title="Test 1. SecurityContextHolder 세팅 및 조회"></a>Test 1. SecurityContextHolder 세팅 및 조회</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@BeforeEach</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">setUp</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 멀티 쓰레드에서 ContextHolder에 인증된 사용자 정보 세팅시,</span></span><br><span class="line">    <span class="comment">// race condition 상태를 피하기 위해서 새로운 SecurityContext를 생성한다.</span></span><br><span class="line">    SecurityContextHolder.setStrategyName(SecurityContextHolder.MODE_THREADLOCAL);</span><br><span class="line">    setMockAuthentication(ANY_USER, ANY_PASSWORD, USER_ROLE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@DisplayName(&quot;SecurityContextHolder에 현재 인증된 사용자 정보를 세팅한다.&quot;)</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">securityContextHolder</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Authentication</span> <span class="variable">authentication</span> <span class="operator">=</span> SecurityContextHolder.getContext().getAuthentication();</span><br><span class="line"></span><br><span class="line">    assertThat(authentication.isAuthenticated()).isTrue();</span><br><span class="line">    assertThat(authentication.getName()).isEqualTo(ANY_USER);</span><br><span class="line">    assertThat(authentication.getCredentials()).isEqualTo(ANY_PASSWORD);</span><br><span class="line">    assertThat(authentication.getAuthorities())</span><br><span class="line">            .extracting(GrantedAuthority::getAuthority)</span><br><span class="line">            .contains(USER_ROLE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setMockAuthentication</span><span class="params">(String principal, String credential, String role)</span> &#123;</span><br><span class="line">    <span class="type">SecurityContext</span> <span class="variable">context</span> <span class="operator">=</span> SecurityContextHolder.createEmptyContext();</span><br><span class="line"></span><br><span class="line">    <span class="type">Authentication</span> <span class="variable">mockAuthentication</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TestingAuthenticationToken</span>(principal, credential, role);</span><br><span class="line">    context.setAuthentication(mockAuthentication);</span><br><span class="line"></span><br><span class="line">    SecurityContextHolder.setContext(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Test-2-Multi-Thread에서-SecurityContextHolder-조회"><a href="#Test-2-Multi-Thread에서-SecurityContextHolder-조회" class="headerlink" title="Test 2. Multi Thread에서 SecurityContextHolder 조회"></a>Test 2. Multi Thread에서 SecurityContextHolder 조회</h3><p>기본적으로 SecurityContextHolder는 <strong>ThreadLocal</strong>을 사용하여 인증된 사용자의 세부 정보를 저장한다.<br>SecurityContextHolder는 메소드에 인수로 명시적으로 전달되지 않더라도, 동일한 쓰레드의 메소드에서 사용할 수 있다.<br>현재 principal의 요청이 처리된 후, 쓰레드를 지우도록 주의를 기울일 경우, ThreadLocal 기반의 방식은 매우 안전하다.<br>Spring Security의 FilterChainProxy는 SecurityContextHolder가 항상 지우는 것을 보장한다. </p><ul><li>일부 어플리케이션은 쓰레드를 사용하는 특정 방식으로 인해, ThreadLocal을 사용하는데 완전히 적합하지 않다.</li><li>예를들어 Swing 클라이언트는 JVM에 모든 쓰레드에서 같은 security context를 사용하기 원한다. </li><li>SecurityContextHolder는 시작할 때 컨텍스트  저장 방법을 지정하는 전략으로 설정할 수 있다.</li><li>Standalone한 어플리케이션의 경우, MODE_GLOBAL 전략을 사용하여 SecurityContextHolder를 사용할 수 있다.</li></ul><h4 id="Multi-Thread에서-exception-handling"><a href="#Multi-Thread에서-exception-handling" class="headerlink" title="Multi Thread에서 exception handling"></a>Multi Thread에서 exception handling</h4><p>Multi thread에서 발생한 exception은 thread 바깥에서 try..catch 블럭을 사용해서 exception 접근이 안된다.<br><strong>UncaughtExceptionHandler를 구현하여 thread에서 발생한 exception을 처리할 수 있다.</strong></p><p>두 가지 방법으로 thread에서 발생한 exception을 처리할 수 있다.</p><ol><li>모든 Thread에서 발생하는 default Exception handler 지정</li><li>Thread 별로 exception handler 지정</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SampleThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.run();</span><br><span class="line"></span><br><span class="line">        Optional.ofNullable(SecurityContextHolder.getContext())</span><br><span class="line">                .map(SecurityContext::getAuthentication)</span><br><span class="line">                .orElseThrow(() -&gt; <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Multi thread...authentication is null&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SampleExceptionHandler</span> <span class="keyword">implements</span> <span class="title class_">Thread</span>.UncaughtExceptionHandler &#123;</span><br><span class="line">    <span class="keyword">private</span> String handlerName;</span><br><span class="line">    <span class="keyword">private</span> Runnable errorHandler;</span><br><span class="line">    <span class="keyword">private</span> CountDownLatch latch;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SampleExceptionHandler</span><span class="params">(String handlerName, Runnable errorHandler)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.handlerName = handlerName;</span><br><span class="line">        <span class="built_in">this</span>.errorHandler = errorHandler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SampleExceptionHandler</span><span class="params">(String handlerName, Runnable errorHandler, CountDownLatch latch)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.handlerName = handlerName;</span><br><span class="line">        <span class="built_in">this</span>.errorHandler = errorHandler;</span><br><span class="line">        <span class="built_in">this</span>.latch = latch;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">uncaughtException</span><span class="params">(Thread t, Throwable e)</span> &#123;</span><br><span class="line">        System.out.println(<span class="built_in">this</span>.handlerName + <span class="string">&quot; : &quot;</span> + e.getMessage());</span><br><span class="line">        <span class="built_in">this</span>.errorHandler.run();</span><br><span class="line">        latch.countDown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@DisplayName(&quot;try...catch 블록으로 thread 외부에서 exception을 핸들링 할 수 없다.&quot;)</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">errorCase</span><span class="params">()</span> &#123;</span><br><span class="line">    Stream.of(<span class="keyword">new</span> <span class="title class_">SampleThread</span>(), <span class="keyword">new</span> <span class="title class_">SampleThread</span>())</span><br><span class="line">            .forEach(thread -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    thread.start();</span><br><span class="line">                    assertThat(<span class="literal">true</span>).isTrue();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    Assertions.fail(<span class="string">&quot;try...catch 블록으로 thread exception 핸들링 할 수 없다.&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Multi-Thread에서-검증을-위한-Unit-Test-작성-계획"><a href="#Multi-Thread에서-검증을-위한-Unit-Test-작성-계획" class="headerlink" title="Multi Thread에서 검증을 위한 Unit Test 작성 계획"></a>Multi Thread에서 검증을 위한 Unit Test 작성 계획</h4><p>Thread가 종료되고 나서, 각각의 exception handler가 호출되었는지 확인한다.</p><ul><li><strong>Thread가 종료될때까지 기다리기 위해서 CountDownLatch를 thread 갯수만큼 선언했다.</strong></li><li>exception Handler에서 에러를 처리하고 나서, latch.countDown() 호출하여, 갯수를 줄여준다.</li><li>latch.await()를 사용하여 latch count가 0이 될때까지 기다린다.</li><li>그 이후에 verify를 통해서, exception handler가 호출되었는지 확인한다.</li></ul><h4 id="1-default-exception-handler-지정"><a href="#1-default-exception-handler-지정" class="headerlink" title="1. default exception handler 지정"></a>1. default exception handler 지정</h4><p>모든 Thread에 적용되는 default exception handler를 지정할 수 있다.</p><ul><li>Thread를 2개를 사용하기 때문에, verify 테스트시에 defaultExceptionHandler가 2번 호출되었는지 확인한다.<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@DisplayName(&quot;Multi Thread 에러 핸들링 - default thread exception handler 지정&quot;)</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">withDefaultExceptionHandler</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">CountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="type">Runnable</span> <span class="variable">defaultErrorHandler</span> <span class="operator">=</span> mock(Runnable.class);</span><br><span class="line">    Thread.setDefaultUncaughtExceptionHandler(<span class="keyword">new</span> <span class="title class_">SampleExceptionHandler</span>(<span class="string">&quot;defaultHandler&quot;</span>, defaultErrorHandler, latch));</span><br><span class="line"></span><br><span class="line">    Stream.of(<span class="keyword">new</span> <span class="title class_">SampleThread</span>(), <span class="keyword">new</span> <span class="title class_">SampleThread</span>()).forEach(SampleThread::start);</span><br><span class="line">    latch.await();</span><br><span class="line"></span><br><span class="line">    then(defaultErrorHandler).should(times(<span class="number">2</span>)).run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="2-Thread-별로-exception-handler-지정"><a href="#2-Thread-별로-exception-handler-지정" class="headerlink" title="2. Thread 별로 exception handler 지정"></a>2. Thread 별로 exception handler 지정</h4><p>Thread 별로 각각의 exception handler 지정할 수 있다.</p><ul><li>각 Thread별로 exceptionHandler를 지정했다.</li><li>Thread가 종료 후에 각각의 exceptionHandler가 한번씩 호출되었는지 확인한다.<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@DisplayName(&quot;Multi Thread 에러 핸들링 - thread마다 exception handler 지정&quot;)</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">withExceptionHandlerEachThread</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">CountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">SampleThread</span> <span class="variable">firstThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SampleThread</span>();</span><br><span class="line">    <span class="type">Runnable</span> <span class="variable">firstExceptionHandler</span> <span class="operator">=</span> mock(Runnable.class);</span><br><span class="line">    firstThread.setUncaughtExceptionHandler(<span class="keyword">new</span> <span class="title class_">SampleExceptionHandler</span>(<span class="string">&quot;firstHandler&quot;</span>, firstExceptionHandler, latch));</span><br><span class="line"></span><br><span class="line">    <span class="type">SampleThread</span> <span class="variable">secondThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SampleThread</span>();</span><br><span class="line">    <span class="type">Runnable</span> <span class="variable">secondExceptionHandler</span> <span class="operator">=</span> mock(Runnable.class);</span><br><span class="line">    secondThread.setUncaughtExceptionHandler(<span class="keyword">new</span> <span class="title class_">SampleExceptionHandler</span>(<span class="string">&quot;secondHandler&quot;</span>, secondExceptionHandler, latch));</span><br><span class="line"></span><br><span class="line">    Stream.of(firstThread, secondThread).forEach(SampleThread::start);</span><br><span class="line">    latch.await();</span><br><span class="line"></span><br><span class="line">    then(firstExceptionHandler).should(times(<span class="number">1</span>)).run();</span><br><span class="line">    then(secondExceptionHandler).should(times(<span class="number">1</span>)).run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="Multi-thread-환경에서-SecurityContextHolder의-전략-수정"><a href="#Multi-thread-환경에서-SecurityContextHolder의-전략-수정" class="headerlink" title="Multi thread 환경에서 SecurityContextHolder의 전략 수정"></a>Multi thread 환경에서 SecurityContextHolder의 전략 수정</h4><p>ThreadLocal기반의 ContextHolder를 사용시, Multi thread 환경에서는 기존 쓰레드에 담긴 내용을 동기화해주는 작업을 별도로<br>진행해야 한다. SecurityContextHolder의 경우는 세가지의 전략을 지원하고, Multi thread 환경에서 적절한 전략을 선택하면 된다.</p><p><strong>Strategy 종류</strong></p><ul><li>MODE_THREADLOCAL : 기본 설정</li><li>MODE_INHERITABLETHREADLOCAL : 멀티 쓰레드에서 새로운 안전한 쓰레드를 생성하는 경우에 기존 쓰레드와 동일하게 사용하고 싶은 경우</li><li>MODE_GLOBAL : standalone application에서 사용</li></ul><p><strong>Unit Test 설명</strong></p><ol><li>SecurityContextHolder의 전략을 MODE_INHERITABLETHREADLOCAL로 지정</li><li>mock 인증 정보 생성</li><li>Multi thread 수행시, SecurityContextHolder에 기존 쓰레드에 지정된 authentication 정보가 새로운 thread에도 지속디는 것을 확인<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@DisplayName(&quot;SecurityContextHolder에서 threadLocal mode변경을 통해서, multi thread에서 동기화 가능&quot;)</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">withGlobalMode</span><span class="params">()</span> &#123;</span><br><span class="line">    SecurityContextHolder.setStrategyName(SecurityContextHolder.MODE_INHERITABLETHREADLOCAL);</span><br><span class="line">    setMockAuthentication(ANY_USER, ANY_PASSWORD, USER_ROLE);</span><br><span class="line"></span><br><span class="line">    <span class="type">Runnable</span> <span class="variable">defaultErrorHandler</span> <span class="operator">=</span> mock(Runnable.class);</span><br><span class="line">    Thread.setDefaultUncaughtExceptionHandler(<span class="keyword">new</span> <span class="title class_">SampleExceptionHandler</span>(<span class="string">&quot;defaultHandler&quot;</span>, defaultErrorHandler));</span><br><span class="line"></span><br><span class="line">    Stream.of(<span class="keyword">new</span> <span class="title class_">SampleThread</span>(), <span class="keyword">new</span> <span class="title class_">SampleThread</span>()).forEach(SampleThread::start);</span><br><span class="line"></span><br><span class="line">    then(defaultErrorHandler).should(never()).run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="마무리"><a href="#마무리" class="headerlink" title="마무리"></a>마무리</h2><p><strong>SecurityContextHolder는 인증된 사용자 정보 저장소로써 역할을 수행한다.<br> 기본적으로 ThreadLocal 기반으로 사용하며, Multi thread 환경에서 기존 인증정보를 sync해서 사용하기 위해서는 strategy 수정이 필요하다.</strong></p><ul><li>메소드 호출시 인증정보를 파라미터로 전달받지 않더라도, SecurityContextHolder에 접근하면 인증된 사용자 정보 확인이 가능하다.</li><li>물론 layer(Controller-Service-Repository)를 넘나들면서 SecurityContextHolder에 접근은 가능하지만, 인증정보를 session 이라고 생각한다면,<br>Presentation Layer의 역할인 Controller에만 SecurityContextHolder에 접근하고, 나머지 layer에서는 메소드 파라미터로 전달받는 것이 바람직해보인다.</li></ul><p><strong>Java 8에서 멀티 쓰레드에서 exception을 다루기 위한 방법</strong>에 대해서도 알아보았다.</p><ul><li>default uncaughtExceptionHandler를 사용하여 모든 쓰레드에 공통적으로 적용</li><li>각 Thread별로 exception handler를 지정</li><li>본문에서 테스트해보지는 않았지만 두 가지 방법을 혼용해서도 사용가능하다.</li></ul><p>마지막으로 Unit Test에서 Multi thread 상태가 종료될 때까지 assertion을 기다리기 위해서,<br><strong>java.util.concurrent.CountDownLatch</strong>를 사용하는 방법도 알아보았다. CountDownLatch를 사용하여 멀티 쓰레드 환경에서 테스트를 작성할 수 있었다.</p><h2 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h2><ul><li><a href="https://github.com/gregor77/start-spring-security/blob/master/src/test/java/com/rhyno/startsecurity/authentication/SecurityContextHolderTest.java">Rhyno Git repository - SecurityContextHolder</a></li><li><a href="https://docs.spring.io/spring-security/site/docs/current/reference/html5/#servlet-authentication-securitycontextholder">Spring security document</a></li><li><a href="http://hochulshin.com/java-multithreading-thread-exception-handling/">Java8 multi thread exception handling</a></li></ul>]]></content:encoded>
      
      
      <category domain="http://gregor77.github.io/categories/Spring-security/">Spring security</category>
      
      
      <category domain="http://gregor77.github.io/tags/Authentication/">Authentication</category>
      
      <category domain="http://gregor77.github.io/tags/Spring-security/">Spring security</category>
      
      <category domain="http://gregor77.github.io/tags/SecurityContextHolder/">SecurityContextHolder</category>
      
      <category domain="http://gregor77.github.io/tags/Multi-Thread/">Multi Thread</category>
      
      <category domain="http://gregor77.github.io/tags/CountDownLatch/">CountDownLatch</category>
      
      <category domain="http://gregor77.github.io/tags/Unit-Test/">Unit Test</category>
      
      
      <comments>http://gregor77.github.io/2021/04/19/spring-security-01/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>서평 - 실전대비 C 알고리즘 인터뷰</title>
      <link>http://gregor77.github.io/2021/01/06/book-review-%EC%8B%A4%EC%A0%84%EB%8C%80%EB%B9%84C%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%EC%9D%B8%ED%84%B0%EB%B7%B0/</link>
      <guid>http://gregor77.github.io/2021/01/06/book-review-%EC%8B%A4%EC%A0%84%EB%8C%80%EB%B9%84C%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%EC%9D%B8%ED%84%B0%EB%B7%B0/</guid>
      <pubDate>Wed, 06 Jan 2021 12:42:28 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;알고리즘은-공부해야-한다&quot;&gt;&lt;a href=&quot;#알고리즘은-공부해야-한다&quot; class=&quot;headerlink&quot; title=&quot;알고리즘은 공부해야 한다?!!&quot;&gt;&lt;/a&gt;알고리즘은 공부해야 한다?!!&lt;/h2&gt;&lt;p&gt;몇 년 전부터 알고리즘 기반의 코딩 </description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="알고리즘은-공부해야-한다"><a href="#알고리즘은-공부해야-한다" class="headerlink" title="알고리즘은 공부해야 한다?!!"></a>알고리즘은 공부해야 한다?!!</h2><p>몇 년 전부터 알고리즘 기반의 코딩 테스트의 중요성이 높아졌다. 특히 회사에서도 알고리즘 테스트를 진행하고 있다. 변명일 수도 있지만 이전에만 하더라도, 나에게 알고리즘은 알고 있으면 좋지만 시간을 들이며 공부할 필요성을 느끼지 못했다.<br>그 시간에 실제 일을 진행하는데 필요한 기술과 지식을 공부하는 게 더 낫다고 생각했다.</p><p>그러고 시간이 흘러 이직을 위해 면접을 보게 되었다. 좋은 기회였음에도 불구하고, 프로젝트도 바쁘고, 한 번에 통과하기 어렵겠지라는 안일한 생각에 충분히 준비를 하지 못했다.<br>코딩 테스트는 몇 년 동안 매일 가장 많은 시간을 보내는 일이 개발이다 보니 막연히 크게 걱정하지 않았다.</p><p>대략 세 시간에 걸쳐 면접을 진행했다. 1시간마다 다른 면접관들과 인터뷰를 진행했고, 마지막은 항상 코딩 테스트를 진행했다. 문제는 비교적 간단한 알고리즘이었다. 하지만 충분히 연습이 되어있지 않는 상태에서, 모르는 알고리즘을 구현하려고 하니 생각대로 잘되지 않았고, 특히 면접이라는 특수한 상황 때문에 막히는 부분들이 생길수록 말리기 시작했다.<br>면접관들과 질의응답은 부족한 상태로 라이브 코딩 테스트를 마무리하게 되었다.</p><p><strong>그 면접 이후로 나는 알고리즘과 코딩 인터뷰는 시간과 노력을 들여서 공부해야 한다 생각하게 되었다.</strong> 현재 대부분의 개발자 채용 과정에서 코딩 테스트는 이루어진다. 물론 채용 인터뷰 과정에서 온전히 내가 어떤 경험과 능력을 가지고 있는지 드러내기는 어렵다고 생각한다.<br>하지만 현실적으로 내가 새로운 기회를 얻기 위해서는 알고리즘을 알아야 하고, 코딩 인터뷰를 잘 진행할 수 있는 준비가 되어있어야 한다.</p><p>알고리즘을 공부하면서 기존에 개발된 시스템에 성능 문제가 발생하면, 어떻게 시간 복잡도를 줄일 수 있을지 고민하게 되고 생각의 범위도 넓혀서 고민할 수 있게 되는 점도 알고리즘 공부를 통해서 얻을 수 있는 이점이다.</p><h2 id="“실전-대비-C-알고리즘-인터뷰“-책을-읽게-되다"><a href="#“실전-대비-C-알고리즘-인터뷰“-책을-읽게-되다" class="headerlink" title="“실전 대비 C 알고리즘 인터뷰“ 책을 읽게 되다."></a>“<a href="http://www.kyobobook.co.kr/product/detailViewKor.laf?ejkGb=KOR&mallGb=KOR&barcode=9791165212957&orderClick=LEa&Kc=">실전 대비 C 알고리즘 인터뷰</a>“ 책을 읽게 되다.</h2><p><img src="/images/book-review/book_cover_c_algorithm_interview.png" alt="#실전대비 C알고리즘 인터뷰"></p><p>면접 실패를 경험하고, 프로젝트도 한가해지면서 알고리즘 공부를 하고 있었다. 길벗에서 진행하는 개발자 리뷰어 기회를 통해서 “실전 대비 C 알고리즘 인터뷰”를 신청하여 읽게 되었다. <strong>책의 목차를 읽고 나서, 나처럼 알고리즘 공부를 시작하는 사람들이나 코딩 인터뷰 경험이 부족한 사람들에게 도움이 되지 않을까 하는 기대가 생겼기 때문이다.</strong><br>이 책을 읽고 나서 이 책을 읽어볼까 고민하고 있을 사람들에게 도움이 되었으면 하는 바람에 내용을 정리해보았다. </p><h2 id="어떤-사람들이-읽으면-도움이-될까"><a href="#어떤-사람들이-읽으면-도움이-될까" class="headerlink" title="어떤 사람들이 읽으면 도움이 될까?"></a>어떤 사람들이 읽으면 도움이 될까?</h2><ul><li><strong>자료구조나 기본적인 알고리즘을 공부하려는 사람</strong></li><li><strong>알고리즘 공부를 시작하려는 입문자</strong></li><li><strong>문제 접근법을 알아도 코드로 구현이 어려운 사람</strong></li></ul><h4 id="“자료구조나-기본적인-알고리즘을-공부하려는-사람”"><a href="#“자료구조나-기본적인-알고리즘을-공부하려는-사람”" class="headerlink" title="“자료구조나 기본적인 알고리즘을 공부하려는 사람”"></a>“자료구조나 기본적인 알고리즘을 공부하려는 사람”</h4><p>책에 절반에 걸쳐서 자료 구조, 기본적인 알고리즘을 다룬다. 이론 설명을 실제로 돌아가는 코드를 통해서 보여주기 때문에 독자가 실제로 예제를 보고 구현할 수 있는 점이 장점이다. 이론 부분만 있거나 의사 코드(pseudocode)만 있는 경우에 실제로 구현하려하면 잘 안되는 경우도 있어 구글에서 검색하는 경우도 많다. 하지만 이 책은 <strong>책만 보고도 알고리즘 구현까지 완성할 수 있는 점이 장점이다.</strong>  </p><h4 id="“알고리즘-공부를-시작하려는-입문자”"><a href="#“알고리즘-공부를-시작하려는-입문자”" class="headerlink" title="“알고리즘 공부를 시작하려는 입문자”"></a>“알고리즘 공부를 시작하려는 입문자”</h4><p>시간 복잡도에 대한 개념이 부족하거나, 시간 복잡도를 개선하는 방법에 미숙한 경우 이 책은 도움이 된다. 실제로 예시를 해결하는 방법을 여러 단계에 걸쳐서 설명을 진행한다. 브루트 포스부터 시작해서 시간 복잡도를 개선할 수 있는 방법으로 설명을 진행한다.</p><p><strong>시간 복잡도 개선하는 방법에 익숙하지 않은 사람의 경우 이 책의 접근 방식은 도움이 될 것이다. 또한 자료구조나 기본적인 알고리즘을 중점으로 다양한 케이스별 예시가 있고, 구현 코드가 반복해서 이어진다. 알고리즘 공부를 시작하려는 입문자가 알고리즘 구현 연습을 할때 참조하기 좋은 책이라 생각한다.</strong></p><h4 id="“문제-접근법을-알아도-코드로-구현이-어려운-사람”"><a href="#“문제-접근법을-알아도-코드로-구현이-어려운-사람”" class="headerlink" title="“문제 접근법을 알아도 코드로 구현이 어려운 사람”"></a>“문제 접근법을 알아도 코드로 구현이 어려운 사람”</h4><p>만약 책을 읽고자 하는 사람이 C 언어를 모르고 다른 프로그래밍 언어만 안다고 하더라도 책을 읽기에 크게 어려움은 없다. 책을 보다 보면 읽는다는 느낌보다는 <strong>알고리즘 유형별로 구현 코드를 참고할 수 있는 쿡북에 가깝다. 케이스별로 실제로 돌아가는 코드가 있기 때문에 문제 접근 방식은 알더라도 코드로 구현하기 어려운 사람이 보기에 좋다.</strong> </p><h2 id="이-책에-부족한-부분"><a href="#이-책에-부족한-부분" class="headerlink" title="이 책에 부족한 부분"></a>이 책에 부족한 부분</h2><ul><li>대부분 코드 위주의 설명으로 진행되기 때문에 알고리즘 유형별 이론적인 설명이나 문제별 접근법에 대한 충분한 설명은 부족하다.</li><li>책을 읽기 전에 기대했었던 코딩 인터뷰를 잘 진행하는 방법에 대한 설명은 너무 짧다.</li></ul><h2 id="마치며"><a href="#마치며" class="headerlink" title="마치며"></a>마치며</h2><p>요즘에는 알고리즘을 공부할 수 있는 다양한 방법들이 존재한다. “백준”같은 온라인 문제풀이 사이트, 온라인 강의, 알고리즘을 다루는 다양한 서적들도 존재한다. 다양한 컨텐츠들 사이에서 막상 알고리즘 공부를 시작하려면 현재 내 수준에 맞는 방법을 찾기 어렵다.</p><p>온라인 문제풀이 사이트에서 문제를 풀어보려고 하면 어떤 알고리즘을 써야할지 생각이 안 떠올를 수도 있고, 알고리즘을 막상 사용하려고 하면 어떻게 구현해야 할지 모르겠는 경우도 있다.</p><p><strong>알고리즘 입문자나 익숙해질 때까지 자료구조, 알고리즘 구현하는 연습을 할 때 이 책은 큰 도움이 된다. 개인적으로는 문제 사이트에서 문제를 풀 때 어떤 자료 구조나 알고리즘을 구현해야 하는데 구현 방법이 떠오르지 않을 때 참고하기에 좋았다.</strong></p><p>마지막으로 알고리즘을 공부하거나 이 책을 읽어보려는 사람들에게 리뷰가 도움이 되었으면 한다. </p>]]></content:encoded>
      
      
      <category domain="http://gregor77.github.io/categories/Review/">Review</category>
      
      
      <category domain="http://gregor77.github.io/tags/SW-Engineering/">SW Engineering</category>
      
      
      <comments>http://gregor77.github.io/2021/01/06/book-review-%EC%8B%A4%EC%A0%84%EB%8C%80%EB%B9%84C%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%EC%9D%B8%ED%84%B0%EB%B7%B0/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>서평 - 심플 소프트웨어</title>
      <link>http://gregor77.github.io/2019/11/19/book-review-simple-sw/</link>
      <guid>http://gregor77.github.io/2019/11/19/book-review-simple-sw/</guid>
      <pubDate>Tue, 19 Nov 2019 11:00:28 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;길벗에 개발자 리뷰 신청 글을 보다가, &lt;strong&gt;100년 뒤에도 유용할 소프트웨어 설계 원칙 &amp;amp; 프로그래머의 바른 길!&lt;/strong&gt; 문구에 이끌려 “심플 소프트웨어”라는 책 리뷰를 하게 되었다.&lt;br/&gt;&lt;br&gt;이전에 “소프트웨어 </description>
        
      
      
      
      <content:encoded><![CDATA[<p>길벗에 개발자 리뷰 신청 글을 보다가, <strong>100년 뒤에도 유용할 소프트웨어 설계 원칙 &amp; 프로그래머의 바른 길!</strong> 문구에 이끌려 “심플 소프트웨어”라는 책 리뷰를 하게 되었다.<br/><br>이전에 “소프트웨어 장인”이라는 책을 인상깊게 읽었는데 그와 비슷한 표지에, 강렬한 문구에 이 책을 읽고나면 깨달음을 얻을 수 있을거란 기대감이 생겼다.</p><h2 id="책을-읽었으면-하는-사람들"><a href="#책을-읽었으면-하는-사람들" class="headerlink" title="책을 읽었으면 하는 사람들"></a>책을 읽었으면 하는 사람들</h2><p><strong>소프트웨어 엔지니어로 일을 하거나, 현재 일하는 방식을 변화하고 싶은 사람들이 읽었으면 합니다. 많은 시행착오로 알게 된 지식들이 깔끔하고 이해하기 쉽게 정리되어 있습니다.</strong></p><p><img src="/images/book-review-simple-sw/%EC%8B%AC%ED%94%8C%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4.jpeg" alt="#심플 소프트웨어"></p><p>3년 넘게 소프트웨어 엔지니어링 팀에 있으면서 많은 개발팀을 만나 생산성을 높이거나, 현재 개발팀의 애로사항을 해결하는 일들을 해왔다. 그 와중에 현재 문제를 해결하기 위해 주로 애자일, XP의 방법을 활용했다. <br/><br>처음에는 방법을 몰라서 프랙티스에 치중을 했다. 하지만 프랙티스만으로는 팀을 변화시키기가 너무 힘들었다. 간혹 강성의 개발자들을 만나면 왜 이런 프랙티스를 해야하는지를 두고 매번 설득과 논쟁(?)의 시간을 겪었고,그럴때마다 정신적으로나 감정적으로 스트레스가 컸다.</p><p>물론 시간이 지나서 돌이켜보니, 내가 너무 어설펐고 애자일에 대한 성숙도가 낮은 상태가 문제의 원인이었다. 그들은 나아지고 있다는 믿음이 없는 상태에서 변화만 요구하는 것처럼 느껴졌을 것이다. 그런 상황이 길어지면서 서로 답답하고 신뢰하지 못하는 상황에서 계속 부딪히다 보니 누군가는 포기하고 서로에게 답답한 시간이었을 것이다.</p><p>이런 시도 반복하다보니, 초반에 개발팀 신뢰를 얻는 것이 중요하다는 것을 알게 되었다. 신뢰를 많이 쌓을수록 팀의 변화는 더 크게 일어났고, 신뢰를 쌓지 못하면 서로 힘들어지고, 이전과 바뀐다는 느낌은 없이 일만 같이하는 사이로 끝나는 경우도 있었다.</p><p><strong>신뢰를 쌓는 일은 개발자들이 현재 일하는데 불편한 점을 찾아서 그것부터 해결해나가다보니 자연스레 얻을 수 있었다. 현재 상황에서 더 나은 상황으로 변할 수 있을거라는 기대감이 생기고 그게 확신으로 변해나가는 경험이 반복될 수록, 이전과 다른 일하는 방식에도 긍정적으로 참여했다. 변화할 수 있다는 확신이 개발자, 팀의 변화에 동기부여가 됐다.</strong></p><h2 id="꼭-읽어야하는-이유"><a href="#꼭-읽어야하는-이유" class="headerlink" title="꼭 읽어야하는 이유"></a>꼭 읽어야하는 이유</h2><p>이전에 이 책을 읽었더라면, 소프트웨어 엔지니어로써 더 많은 개발자에게 도움이 되었을텐데라는 생각이 가장 먼저 들었다. 시행착오를 통해 알게된 내용들이 너무 잘 정리되어있었다. 개발자들과 많은 이야기를 하다보면 개인 경험치에 따라 공유하는 내용의 깊이가 달라진다. 내용의 깊이에 따라 사람들을 얼마나 몰입시키는지가 결정된다.<br/><br>이 책을 읽으면서 느낀점은 <strong>독자가 현재 상황을 개선하기 위해서 많은 경험을 했고, 얼마나 많은 고민을 했었는지가 느껴졌다. 책에 나와있는 상황들에 몰입이 되었고, 내가 현재 일하는 환경에 연결되어 내 상황은 어떤지, 나는 어떤 선택을 할 것인지 돌이켜보게 된다.</strong></p><ul><li>소프트웨어 엔지니어라면 많은 경험을 통해 알 수 있는 점들이 잘 정리되어 있다.</li><li>팀의 변화를 시도하고 싶은 사람이 어떤 방법을 통해 해결해야 할지 모르는 경우, 방법을 알려주는 지침서가 될거라 생각한다.</li><li>심플 디자인의 중요성을 다양한 사례를 통해서 공감할 수 있다.</li><li>경험이 적은 주니어 개발자나 혹은 혼자 일하고 있는 개발자들에게 조언이 된다.</li><li>개발 코드가 없어서 몰입해서 가볍게 읽을 수 있다.</li></ul><h2 id="아쉬운-점"><a href="#아쉬운-점" class="headerlink" title="아쉬운 점"></a>아쉬운 점</h2><p>책의 표지를 보면 “코드의 단순성, 가독성, 안전성, 유지보수를 위한 심플 소프트웨어”라고 되어있다. 그것만 보고 개발코드를 예를 들면서 복잡도를 낮추는 설계 방법이 있을거라 기대하는 사람들은 실망할 수 있다.<br/><br>이 책은 코드의 단순성, 가독성, 안정성, 유지보수를 위한 심플 소프트웨어가 왜 중요한지 배경 설명을 위한 책이다. <strong>상황에 따른 경험담을 바탕으로 왜 심플 소프트웨어를 만들어야하는지, 어떤 방법으로 목적을 달성할 수 있는지 소프트웨어 공학 관련된 내용이기 때문에 클린 코드를 위한 코딩 가이드를 기대하지 마라.</strong></p><h2 id="마무리"><a href="#마무리" class="headerlink" title="마무리"></a>마무리</h2><p><strong>개발하는 사람이라면 꼭 한번은 읽어봤으면 하는 책이다. 개발자로써 경험이 달라져도 그때마다 새로운 인사이트를 얻을 수 있는 책이라 생각한다.</strong><br>내 역할이 개발자, 소프트웨어 엔지니어, 팀리더 등으로 변하더라도 그때마다 얻는 가치들이 분명이 존재할거라 생각합니다.<br/></p><p>알게된 내용을 현재 내 상황에 적용해 본다면 더 즐거울거라 생각합니다. <strong>내가 개발업무를 하던, 운영업무를 하던 소프트웨어 개발을 하고, 유지보수를 하고 있는 사람이라면 현재의 상황을 개선하는데 도움되는 실용적인 팁을 얻을 수 있을 것입니다.</strong> 그러기 위해서는 단순히 내용만 읽고 넘기는 것이 아니라, 책의 상황에 몰입하고 고민해야 더 큰 깨달음을 얻을거라 생각합니다.</p>]]></content:encoded>
      
      
      <category domain="http://gregor77.github.io/categories/Review/">Review</category>
      
      
      <category domain="http://gregor77.github.io/tags/SW-Engineering/">SW Engineering</category>
      
      
      <comments>http://gregor77.github.io/2019/11/19/book-review-simple-sw/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>서평 - 혼자 공부하는 C언어</title>
      <link>http://gregor77.github.io/2019/09/14/book-review-study-c-alone/</link>
      <guid>http://gregor77.github.io/2019/09/14/book-review-study-c-alone/</guid>
      <pubDate>Sat, 14 Sep 2019 13:14:28 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;책을-읽게된-배경&quot;&gt;&lt;a href=&quot;#책을-읽게된-배경&quot; class=&quot;headerlink&quot; title=&quot;책을 읽게된 배경&quot;&gt;&lt;/a&gt;책을 읽게된 배경&lt;/h2&gt;&lt;p&gt;한빛미디어에서 진행하는 “나는 리뷰어다” 8월 미션을 통해서 이 책을 읽고 </description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="책을-읽게된-배경"><a href="#책을-읽게된-배경" class="headerlink" title="책을 읽게된 배경"></a>책을 읽게된 배경</h2><p>한빛미디어에서 진행하는 “나는 리뷰어다” 8월 미션을 통해서 이 책을 읽고 리뷰를 남기게 되었다. 현재 학교를 졸업하고 개발자로써 9년차에 접어들었다. 주로 자바와 자바스크립트를 사용하여 개발을 진행해왔고, 학교에서만 C언어, 자료구조와 알고리즘, 운영체제 과목을 통해서만 C를 접했지 회사에서 일하면서 C를 접한적은 한번도 없는 것 같다. </p><p>학교다닐때도 처음 접한 C는 너무 어려운 프로그래밍 언어였다. 이중 포인터의 능선을 넘기지 못하고 쥐쥐친 언어로 기억하고 있다. 그 이후에 C로 실습하는 과목들 또한 어려웠고 그것때문인지 모르겠지만 일단 C언어라고 하면 어려운 언어라는 편견이 있다. 이번에 “나는 리뷰어다” 이벤트를 통해서 이 책을 신청하게 된 이유는, 지금 C언어를 공부해도 학생때 처럼 똑같이 어려울까 하는 호기심과 최근에 알고리즘 공부를 하려고 하는데 C언어로 공부하면 재미있을거 같아서였다.</p><p>이 책을 읽지 않은 상태에서 <strong>먼저 목차를 봤을때 초급편, 고급편으로 나눈 구성이 마음에 들었다. 그리고 배타리더의 만족스러운 소감들이 책 제목처럼 혼자 공부해서 C언어라는 큰 벽을 오를 수 있지 않을까라는 기대가 생겼다.</strong></p><p><img src="/images/book-review-study-c-alone/%ED%98%BC%EC%9E%90%EA%B3%B5%EB%B6%80%ED%95%98%EB%8A%94C%EC%96%B8%EC%96%B4.jpg" alt="#혼자 공부하는 C언어"></p><h2 id="좋았던-점"><a href="#좋았던-점" class="headerlink" title="좋았던 점"></a>좋았던 점</h2><h4 id="“C언어를-알고-싶은-누구나-읽기에-부담스럽지-않다-”"><a href="#“C언어를-알고-싶은-누구나-읽기에-부담스럽지-않다-”" class="headerlink" title="“C언어를 알고 싶은 누구나 읽기에 부담스럽지 않다.”"></a>“C언어를 알고 싶은 누구나 읽기에 부담스럽지 않다.”</h4><p>이 책은 초심자나 프로그래밍 경험이 없는 사람들이 읽기에 전혀 부담스럽지 않을 것 같다. 전공서적임에도 불구하고 책의 내용이 딱딱하거나 재미없다고 느껴지지 않는다. <strong>익숙하지 않은 용어에 대해서 설명을 해주고, 이미지를 많이 활용해서 쉽게 이해할 수 있게 도와주기 때문이다.</strong></p><p>그리고 챕터가 시작할때 개념적인 부분을 실생활에 찾을 수 있는 예를 들어 설명하는 부분이 독자로 하여금 왜 이런 부분이 필요한 것인지 공감할 수 있게 한다. 단순히 문법으로 바로 시작했으면 딱딱하거나 어렵게 느껴질 수 있었을텐데 저자가 독자에 대한 배려가 많다는 느낌이 들었다.</p><h4 id="“어려운-내용도-이해하기-쉽게-설명해-준다-”"><a href="#“어려운-내용도-이해하기-쉽게-설명해-준다-”" class="headerlink" title="“어려운 내용도 이해하기 쉽게 설명해 준다.”"></a>“어려운 내용도 이해하기 쉽게 설명해 준다.”</h4><p>학부생때 포인터와 이중 포인터에서 머리가 안돌아가서 포기했었다. 이번 리뷰의 개인적인 목표는 포인터 관련 부분을 이해할 수 있을 것인가 하는 거였다. 일단 책에서는 포인터 내용이 고급편에 포함되어 있어 상대적으로 위안이 되었다. 내가 너무 빠르게 C언어를 포기하지 않았구나라는 점에서 말이다. ㅎㅎ</p><p><strong>책을 읽으면서 간결한 문체가 책 보는 내내 집중할 수 있어서 좋았다.</strong> 전공서적을 읽다보면 너무 어렵게 설명을 하거나 또는 문체가 길어서 무슨 말을 하는지 이해하지 못하는 경우가 있는데, 이 책에서는 그러는 경우가 단 한번도 없었다. <strong>그리고 개념적인 부분을 그림을 통해서 부가 설명을 해주는데 그 덕분에 이해하기 쉬웠다.</strong> </p><p>이 책을 보면서 내가 대학생때 이 책이 있었다면 C언어를 포기하지 않았을텐데 생각이 들었다. 왜냐면 학부생때 봤던 책은 정말 내용이 딱딱했고, 개념적인 부분에 대한 설명이 충분치 않았다. 교수님이 분명 설명해줬지만 내가 이해하지 못한 상태서 계속 다음 진도를 나가니 결국엔 따라가지 못하고 포기했었다. 하지만 이렇게 잘 설명되어 있는 책이 있었다면 개인적으로 공부하면서 수업을 따라갈 수 있었을 것 같다는 생각이 들었다.</p><h2 id="마무리"><a href="#마무리" class="headerlink" title="마무리"></a>마무리</h2><p>새로운 프로그래밍 언어를 공부할 때 가장 좋은 방법은 많이 사용해보는 것이다. <strong>새롭게 알게된 C언어 문법을 알고리즘 문제를 푸는데 활용해보자.</strong> 꼭 어려운 알고리즘 문제가 아니더라도, 간단한 알고리즘 문제를 C언어로 풀어보면서 문법에 익숙해질 수 있었다. <a href="https://www.acmicpc.net/">백준 알고리즘</a> 사이트에는 다양한 알고리즘 문제가 많으니 관심있는 사람들은 참고해도 좋을 것 같다.</p><p><strong>마지막으로 이 책은 C언어를 공부할때 필요한 내용은 다 다루고 있기 때문에, 초심자나 다시 공부해보려는 사람들에게 좋은 지침서가 될 것이라 생각한다. 그리고 자료구조나 알고리즘을 C언어로 공부해보면 자연스럽게 배운 내용을 활용할 수 있기 때문에 병행하는 것도 추천한다.</strong></p>]]></content:encoded>
      
      
      <category domain="http://gregor77.github.io/categories/Review/">Review</category>
      
      
      <category domain="http://gregor77.github.io/tags/C-%EC%96%B8%EC%96%B4/">C 언어</category>
      
      
      <comments>http://gregor77.github.io/2019/09/14/book-review-study-c-alone/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Hexo Hueman Theme 블로그 - 파싱할 수 없는 구조화된 데이터</title>
      <link>http://gregor77.github.io/2019/08/19/hexo-hueman-unparsed-structured-data/</link>
      <guid>http://gregor77.github.io/2019/08/19/hexo-hueman-unparsed-structured-data/</guid>
      <pubDate>Mon, 19 Aug 2019 04:35:09 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;Hexo Hueman 테마를 사용하여 개발자 블로그를 운영중이다. 그런데 새로 작성한 글들이 구글에서 조회가 되지 않는 것이다.&lt;br&gt;처음에는 크롤링을 하지 않아서 그런 것이겠지 했는데, 몇일이 지나도 계속 조회가 되지 않았다.&lt;br&gt;이번 글은 </description>
        
      
      
      
      <content:encoded><![CDATA[<p>Hexo Hueman 테마를 사용하여 개발자 블로그를 운영중이다. 그런데 새로 작성한 글들이 구글에서 조회가 되지 않는 것이다.<br>처음에는 크롤링을 하지 않아서 그런 것이겠지 했는데, 몇일이 지나도 계속 조회가 되지 않았다.<br>이번 글은 Google Search Console을 통해서 구글에서 작성한 글이 검색되도록 한 과정과 용어들을 공유하겠다. </p><h2 id="Google-Search-Console"><a href="#Google-Search-Console" class="headerlink" title="Google Search Console"></a>Google Search Console</h2><p>처음 개발자 블로그를 만들고 <strong>구글에 블로그를 노출시키기 위해서, sitemap을 추가하기 위해 Google Search Console을 처음 접했다.</strong><br>그리고 얼마후 블로그에 게시한 글들이 구글에서 조회가 되는 것을 보고, 그 이후에는 Google Search Console에 따로 접속하지 않았다.</p><p>최초에 landscape 테마를 사용하다가, 너무 클래식한거 같아서 Hueman 테마로 변경했다. 그런데 Hueman 테마로 변경후부터 구글에서 새로운 글이 검색이 되지 않았다.<br>Google Search Console에 접속해서 “실적” 메뉴를 보면 페이지 노출수를 확인할 수 있다. 예상대로 새로 작성된 post 자체가 보이지 않았다.</p><p><img src="/images/hexo-hueman-unparsed-structured-data/google-search-console.png" alt="#Google Search Console - 실적 메뉴"></p><p>Search Console에 등록된 블로그의 sitemap.xml은 잘 조회되고 있었기 때문에, 혹시 Googlebot이 크롤링을 제대로 못하는 것이 아닌가 의심이 갔다.<br>Search Console에서 “URL 검사”라는 메뉴를 사용하면 입력된 URL 주소로 Google에서 생성한 색인의 현재 상태를 확인할 수 있었다.</p><p><strong>원인은 Hueman Theme에서 새로 작성한 글들은 “파싱할 수 없는 구조화된 데이터” 에러를 발생하고 있었고 Googlebot이 크롤링을 실패하면서 검색이 안 되는 것이었다.</strong><br>에러 내용을 클릭하면, 오른쪽 탭에 “크롤링된 페이지” 상세 정보를 확인할 수 있고, 마치 개발자도구 처럼 어디 부분에서 에러가 발생했는지 확인할 수 있다.<br>이미 크롤링되서 색인된 페이지가 아닌, URL 기반으로 실시간으로 테스트를 해서 현재 페이지의 상태를 확인하고, 색인생성 가능여부를 판단할 수 있다  .</p><p><img src="/images/hexo-hueman-unparsed-structured-data/url-test2-realtime-test.png" alt="#URL 검사 - &quot;파싱할 수 없는 구조화된 데이터&quot;"></p><h4 id="해결방법-구조화된-데이터-테스팅-도구"><a href="#해결방법-구조화된-데이터-테스팅-도구" class="headerlink" title="해결방법 : 구조화된 데이터 테스팅 도구"></a>해결방법 : <a href="https://search.google.com/structured-data/testing-tool">구조화된 데이터 테스팅 도구</a></h4><p>구조화된 데이터 테스트 도구를 사용하면, 입력된 URL에 조회되는 데이터의 구문을 수정하고 테스트 할 수 있다. 마치 개발자 도구처럼 데이터를 수정할 수 있고, 오른쪽에 현재 데이터 상태를 바로 확인할 수 있기 때문에 편하다.<br>URL에 내 블로그에 등록된 글 주소를 입력해보았는데 역시나 구조화된 데이터로 파싱되지 못하는 에러가 있었다.</p><h5 id="오류-카테고리가-없는-오류-Object-parsing-실패"><a href="#오류-카테고리가-없는-오류-Object-parsing-실패" class="headerlink" title="[오류] 카테고리가 없는 오류 - Object parsing 실패"></a><strong>[오류] 카테고리가 없는 오류 - Object parsing 실패</strong></h5><ul><li>JSON-LD: 개체 선언에 “,” 또는 “}”가 누락되었습니다.</li><li>JSON-LD 값을 확인하면, “description”의 값 다음에 “,”가 없어서 제대로된 Object로 인지를 못한다.<br><img src="/images/hexo-hueman-unparsed-structured-data/structured-data-test-tool.png" alt="#카테고리가 없는 오류"></li></ul><p>description의 값 다음에 “,”을 추가하고 다시 테스트를 해보면, 해당 에러는 없어지고 JSON-LD에 publisher, mainEntityOfPage 속성을 추가하라는 경고와 오류가 발생한다.<br><img src="/images/hexo-hueman-unparsed-structured-data/json-ld-add-attributes.png" alt="#BlogPosting - publisher, mainEntityOfPage 추가"></p><h5 id="오류-JSON-LD-속성-추가-publisher-mainEntityOfPage"><a href="#오류-JSON-LD-속성-추가-publisher-mainEntityOfPage" class="headerlink" title="[오류] JSON-LD 속성 추가 - publisher, mainEntityOfPage"></a><strong>[오류] JSON-LD 속성 추가 - publisher, mainEntityOfPage</strong></h5><p><strong>Hexo에 Hueman 테마를 보면 ld_json.ejs 파일이 있다.</strong> 파일을 보면, JSON을 사용하여 JSON을 RDF로 변환하는데 필요한 모델의 추가적인 매핑정보가 작성되어 있다.<br>JSON-LD를 표현하는 방식은 <a href="https://schema.org/">Schema.org 사이트</a>를 참고하면 의미와 사용법에 대해서 상세히 설명되어 있다.<br>아래처럼 ld_json.ejs 파일을 변경하고, hexo로 다시 deploy 후 Google Search Console에서 실시간 URL 검사를 하면 정상적으로 나오는 것을 확인할 수 있다.<br><strong>hexo deploy를 한다고 해서 Googlebot이 바로 크롤링을 하지 않기 때문에, 실시간 테스트를 통해 테스트를 해야한다.</strong></p><ul><li><strong>description의 값 뒤에 “,” 추가</strong></li><li><strong><a href="https://schema.org/publisher">publisher</a> 속성 추가</strong><ul><li>페이지의 출판자를 의미</li></ul></li><li><strong><a href="(https://schema.org/mainEntityOfPage">mainEntityOfPage</a> 속성 추가</strong><ul><li>설명중인 주요 항목인 페이지에 대한 설명을 의</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ld_json.ejs 파일 변경</span></span><br><span class="line">&lt;script type=<span class="string">&quot;application/ld+json&quot;</span>&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;@context&quot;</span>: <span class="string">&quot;https://schema.org&quot;</span>,</span><br><span class="line">        <span class="string">&quot;@type&quot;</span>: <span class="string">&quot;BlogPosting&quot;</span>,</span><br><span class="line">        <span class="string">&quot;author&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;@type&quot;</span>: <span class="string">&quot;Person&quot;</span>,</span><br><span class="line">            <span class="string">&quot;name&quot;</span>: <span class="string">&quot;&lt;%= config.author %&gt;&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &lt;% <span class="keyword">if</span> (post.<span class="property">title</span>) &#123; %&gt;<span class="string">&quot;headline&quot;</span>: <span class="string">&quot;&lt;%= post.title %&gt;&quot;</span>,&lt;% &#125; %&gt;</span><br><span class="line">        <span class="string">&quot;image&quot;</span>: <span class="string">&quot;&lt;%- url_for(config.url + thumbnail(post)) %&gt;&quot;</span>,</span><br><span class="line">        &lt;% <span class="keyword">if</span> (post.<span class="property">tags</span>) &#123; %&gt;<span class="string">&quot;keywords&quot;</span>: <span class="string">&quot;&lt;%- post.tags.map(t =&gt; t.name).join(&#x27; &#x27;) %&gt;&quot;</span>,&lt;% &#125; %&gt;</span><br><span class="line">        &lt;% <span class="keyword">if</span> (post.<span class="property">categories</span>) &#123; %&gt;<span class="string">&quot;genre&quot;</span>: <span class="string">&quot;&lt;%- post.categories.map(c =&gt; c.name).join(&#x27; &#x27;) %&gt;&quot;</span>,&lt;% &#125; %&gt;</span><br><span class="line">        <span class="string">&quot;datePublished&quot;</span>: <span class="string">&quot;&lt;%- date(post.date, &#x27;YYYY-MM-DD&#x27;) %&gt;&quot;</span>,</span><br><span class="line">        <span class="string">&quot;dateCreated&quot;</span>: <span class="string">&quot;&lt;%- date(post.date, &#x27;YYYY-MM-DD&#x27;) %&gt;&quot;</span>,</span><br><span class="line">        &lt;% <span class="keyword">if</span> (post.<span class="property">updated</span>) &#123; %&gt;<span class="string">&quot;dateModified&quot;</span>: <span class="string">&quot;&lt;%- date(post.updated, &#x27;YYYY-MM-DD&#x27;) %&gt;&quot;</span>,&lt;% &#125; %&gt;</span><br><span class="line">        <span class="string">&quot;url&quot;</span>: <span class="string">&quot;&lt;%- url_for(config.url + &#x27;/&#x27; + post.path) %&gt;&quot;</span>,</span><br><span class="line">        <span class="string">&quot;description&quot;</span>: <span class="string">&quot;&lt;%- excerpt(post) %&gt;&quot;</span>,</span><br><span class="line">        <span class="string">&quot;wordCount&quot;</span>: <span class="string">&quot;&lt;%- post.content.split(&#x27; &#x27;).length %&gt;&quot;</span>,</span><br><span class="line">        <span class="string">&quot;publisher&quot;</span>: <span class="string">&quot;&lt;%= config.author %&gt;&quot;</span>,</span><br><span class="line">        <span class="string">&quot;mainEntityOfPage&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;@type&quot;</span>: <span class="string">&quot;WebPage&quot;</span>,</span><br><span class="line">            <span class="string">&quot;@id&quot;</span>: <span class="string">&quot;&lt;%- url_for(config.url + &#x27;/&#x27; + post.path) %&gt;&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><img src="/images/hexo-hueman-unparsed-structured-data/search-console-url-success.png" alt="#Google Search Console - URL 실시간 검사 성공"></p><h2 id="SEO-Sementic-Web-JSON-LD"><a href="#SEO-Sementic-Web-JSON-LD" class="headerlink" title="SEO, Sementic Web, JSON-LD"></a>SEO, Sementic Web, JSON-LD</h2><p>구글에서는 크롤링을 할때 수집하려는 리소스가 구조화된 데이터인지를 확인하고, 구조화된 데이터인 경우만 정상적으로 크롤링을 하고 색인을 만드는 과정을 거친다.<br>그리고 사용자가 검색시, 구글 검색 사이트에서 검색 결과는 생성된 색인들 내에서 조회되는 과정을 거친다.</p><p><img src="/images/hexo-hueman-unparsed-structured-data/semantic-web.png" alt="#Semantic Web과 Schema.org 관계"></p><h4 id="검색-엔진-최적화-Search-Engine-Optimization-SEO"><a href="#검색-엔진-최적화-Search-Engine-Optimization-SEO" class="headerlink" title="검색 엔진 최적화 (Search Engine Optimization, SEO)"></a>검색 엔진 최적화 (Search Engine Optimization, SEO)</h4><p>블로그 글을 작성하면서, 내가 작성한 글이 비슷한 고민을 하는 사람에게 노출되면 좋을 것 같다는 생각을 했다. 개인도 이러한데 특히 온라인 쇼핑몰이나 돈이 오가는 사이트의 경우, 사용자가 키워드로 검색시 상위에 노출되는 것이 매출과 직결될 것이다.</p><blockquote><p>검색엔진최적화는 웹 페이지 검색엔진이 자료를 수집하고 순위를 매기는 방식에 맞게 웹 페이지를 구성해서 검색 결과의 상위에 나올 수 있도록 하는 작업을 말한다.<br>-위키피디아: 검색 엔진 최적화-</p></blockquote><h4 id="Semantic-Web"><a href="#Semantic-Web" class="headerlink" title="Semantic Web"></a>Semantic Web</h4><p>작성중</p><h4 id="Schema-org"><a href="#Schema-org" class="headerlink" title="Schema.org"></a>Schema.org</h4><p>작성중</p><h4 id="JSON-LD"><a href="#JSON-LD" class="headerlink" title="JSON-LD"></a>JSON-LD</h4><p>작성중</p><h2 id="결론"><a href="#결론" class="headerlink" title="결론"></a>결론</h2><p>Hexo와 Github을 이용해서 개발자 블로그를 만들면서 SEO (검색엔진최적화)란 용어를 처음 들었다. 구글, 네이버, 다음 검색사이트에 블로그를 노출하기 위했던 일들을 생각해보자.</p><ol><li>sitemap 또는 rss 생성 및 웹마스터 도구 등록</li></ol><ul><li>네이버는 rss2방식을 제공하기 때문에 추가함</li></ul><ol start="2"><li>robots.txt 생성</li></ol><ul><li>robots.txt 파일을 통해서 검색 사이트에서 크롤러가 작업을 할때 블로그에 크롤링 가능한 파일, 불가능 파일을 정리하고 거기에 따르도록 지시할 수 있다.</li><li>구글 같은 경우에는 크롤링이 실패할 경우, 새로 작성한 파일의 색인을 만들지 못하고, 변경한 글의 경우 이전에 작성한 내용이 노출되었다.</li></ul><p><strong>사내 시스템이나 B2B 사이트를 만들때는 전혀 생각하지 못했던 것들을 Hexo + Github으로 개발자 블로그를 만들면서 “SEO (검색엔진최적화)를 위한 Tip”을 알게 되서 의미있었다.</strong><br>Blog를 손쉽게 만들어주는 Hexo나 Jekyll 각각 마다 손쉽게 SEO를 적용할 있는 라이브러리들이 많았다. 블로그를 검색 사이트에 노출하기 위한 작업을 통해서 어떻게 검색사이트가 리소스들을 검색엔진에 노출시키는지 이해할 수 있었다.</p><h2 id="참조-사이트"><a href="#참조-사이트" class="headerlink" title="참조 사이트"></a>참조 사이트</h2><ul><li><a href="https://support.google.com/webmasters/answer/9166415#error_types">[Google Search Console - 파싱할 수 없는 구조화된 데이터 보고서]</a></li><li><a href="https://ko.wikipedia.org/wiki/JSON-LD">[JSON-LD 위키피디아 설]</a></li><li><a href="https://blog.outsider.ne.kr/1214">[Outsider님의 Schema.org로 웹 컨텐츠 조화하기 ]</a></li></ul>]]></content:encoded>
      
      
      <category domain="http://gregor77.github.io/categories/Blog/">Blog</category>
      
      
      <category domain="http://gregor77.github.io/tags/SEO/">SEO</category>
      
      <category domain="http://gregor77.github.io/tags/Google-Search-Console/">Google Search Console</category>
      
      <category domain="http://gregor77.github.io/tags/Blog/">Blog</category>
      
      <category domain="http://gregor77.github.io/tags/%EA%B5%AC%EC%A1%B0%ED%99%94%EB%90%9C-%EB%8D%B0%EC%9D%B4%ED%84%B0/">구조화된 데이터</category>
      
      <category domain="http://gregor77.github.io/tags/Semantic-Web/">Semantic Web</category>
      
      <category domain="http://gregor77.github.io/tags/structure-data/">structure data</category>
      
      <category domain="http://gregor77.github.io/tags/Schema-org/">Schema.org</category>
      
      <category domain="http://gregor77.github.io/tags/JSON-LD/">JSON-LD</category>
      
      <category domain="http://gregor77.github.io/tags/%EA%B2%80%EC%83%89%EC%97%94%EC%A7%84%EC%B5%9C%EC%A0%81%ED%99%94/">검색엔진최적화</category>
      
      
      <comments>http://gregor77.github.io/2019/08/19/hexo-hueman-unparsed-structured-data/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Unit Test (단위 테스트) 에 관한 생각</title>
      <link>http://gregor77.github.io/2019/08/16/about-unit-test/</link>
      <guid>http://gregor77.github.io/2019/08/16/about-unit-test/</guid>
      <pubDate>Fri, 16 Aug 2019 02:27:10 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;지금 부서의 역할이 사내에서 제품을 가지고 있는 팀들과 협업을 하면서 기존에 문제를 해결하고 사용자 관점에서 더 가치있는 제품을 항상 딜리버리 가능한 상태로 만드는 것을 목표로 하고 있다.&lt;br&gt;기존의 문제를 해결하는 방법으로 Agile의 Pra</description>
        
      
      
      
      <content:encoded><![CDATA[<p>지금 부서의 역할이 사내에서 제품을 가지고 있는 팀들과 협업을 하면서 기존에 문제를 해결하고 사용자 관점에서 더 가치있는 제품을 항상 딜리버리 가능한 상태로 만드는 것을 목표로 하고 있다.<br>기존의 문제를 해결하는 방법으로 Agile의 Practice를 필요에 따라 활용하고 있으며, 특히 개발 Practice로는 TDD, Unit Test, Code Review, Pair Programming, CI&#x2F;CD 자동화, Build Monitor 등의 프랙티스를 가져간다.</p><p>개발자로서 프로젝트를 진행하면서 TDD까지 전파하는 것은 정말 어려운 일이고, TDD까지 가기전에 Unit Test 작성하는 것은 제1순위로 전파하려고 하는 편이다.<br>테스트케이스 작성하는 방법을 체득화하고 그 이후에 TDD까지 이어가려고 하는데, 개발하는 습관이나 사고방식이 함께 바껴져야 하기 때문에 TDD까지 팀에 체득화 시키는 것은 항상 쉽지 않았다.<br>TDD에 대해서는 할말이 너무 많지만, 이번 글은 Unit Test (단위 테스트)에 대해서 개인적인 글을 써보겠다.</p><h2 id="단위-테스트-장점"><a href="#단위-테스트-장점" class="headerlink" title="단위 테스트 장점"></a>단위 테스트 장점</h2><p>테스트케이스를 꼼꼼하게 작성을 하면서 내가 변경한 부분이 어디에 영향을 끼치는지 쉽게 파악할 수 있었다. 그 덕에 안심하고 리팩토링을 할 수 있는 점이 가장 좋았다.<br>단위 테스트를 하지 않는다면 제대로 수정했는지 확인될때까지 로컬에서 확인을 했을 것이다. 만약 오류가 발생하면 디버깅을 통해서 확인하는 작업을 반복했을 것이다.</p><p>이렇게 소요되는 시간을 포함해서 생각해본다면 “단위테스트 작성때문에 생산성이 떨어지는 것은 아니냐?” 라는 의문에 대해서 그래도 얻는 장점이 더 많다고 말할 수 있지 않을까 생각한다.</p><p><img src="/images/unit-test-anti-pattern/no-unit-test-task-cycle.png" alt="# 단위 테스트가 없다면 어떻게 작업을 했을까?"></p><p>단위 테스트 작성시 무엇이 좋았더냐?</p><ul><li>테스트케이스가 꼼꼼하게 작성되어 있다면, 개발과정 중에 미리 문제를 파악할 수 있다.</li><li>코드변경시, 변경한 부분으로 인한 영향도를 쉽게 파악할 수 있다.</li><li>코드 리팩토링을 안심하고 할 수 있다. 테스트케이스들은 내가 가입한 보험들 같다.</li><li>테스트 자동화를 통해서 항상 딜리버리 가능한 제품을 만들 수 있다.</li><li>새로운 입력이 팀에 합류했을때, 개발 스타일, 표준, 컨벤션등을 공유하기에 좋다. </li><li>페어 프로그래밍을 할때, 테스트케이스 작성하고 개발하는 역할 핑퐁을 통해서 개발을 페어로 집중해서 진행할 수 있다.<ul><li>TDD + Pair Programming을 한다면, 테스트케이스 작성한 사람의 설계를 공유하면서 소스 개발까지 이어질 수 있으므로 집중력있게 개발할 수 있다.</li></ul></li></ul><h2 id="테스트케이스에-대한-걱정"><a href="#테스트케이스에-대한-걱정" class="headerlink" title="테스트케이스에 대한 걱정"></a>테스트케이스에 대한 걱정</h2><p>기존에 단위 테스트를 작성하지 않는 개발자분들과 프로젝트를 할때, 공통적으로 듣는 질문이나 내용들이 있다. 그렇다면 질문에 대해서 하나씩 생각해보자.<br>아직 해보지 않았거나 어떻게 해야할지 모르기 때문에 생각보다 두려움이 더 커져서 시도하기 어려울 수도 있다. 하지만 그 방법을 알거나 조금씩 해결할 수 있다면 단위 테스트를 적용할 수 있을 것이다.</p><h4 id="Q-기존에-레거시-코드는-어떻게-해야하나"><a href="#Q-기존에-레거시-코드는-어떻게-해야하나" class="headerlink" title="Q. 기존에 레거시 코드는 어떻게 해야하나?"></a>Q. 기존에 레거시 코드는 어떻게 해야하나?</h4><p>기존에 만들어진 코드에 모두 테스트 케이스를 만드는 것은 상당히 어렵다. 시간적인 여유가 팀원들이 함께 짤 수 있다면 시도를 해보는 것은 나쁘지 않다.<br>하지만 이미 만들어진 코드의 규모가 크면 열정만으로는 다 커버하기가 쉽지 않다. 게다가 테스트 작성하는 법을 잘 모르고 있다면 익숙해지기 전까지 시간이 오래 걸린다.<br>투자한 노력에 비해서 아직 커버해야하는 부분이 많이 남아있다는 것을 확인하는 순간 지칠수도 있다.</p><ul><li><strong>기존의 레거시 코드는 E2E 테스트로 커버한다.</strong></li><li><strong>새로 개발하거나 변경하는 부분을 대상으로 단위 테스트를 시작하라.</strong></li></ul><p>그렇게 하면 시간은 오래걸릴 수 있지만, 점차적으로 단위 테스트를 늘려갈 수 있을 것이다. E2E 테스트또한 기능이 복잡하거나 중요한 기능부터 커버하기 시작하라. 그렇다면 효율적으로 단위테스트 적용이 가능할 것이다.</p><h4 id="Q-소스를-변경할때마다-단위테스트가-실패하면-유지보수-하는데-시간이-들지-않나"><a href="#Q-소스를-변경할때마다-단위테스트가-실패하면-유지보수-하는데-시간이-들지-않나" class="headerlink" title="Q. 소스를 변경할때마다 단위테스트가 실패하면 유지보수 하는데 시간이 들지 않나?"></a>Q. 소스를 변경할때마다 단위테스트가 실패하면 유지보수 하는데 시간이 들지 않나?</h4><p>TDD(Test Driven Development, 테스트주도개발)의 라이프 사이클을 보면 테스트를 작성하고, 실패하는 것을 확인하고, 테스트가 통과하도록 고친다. 그이후에 리팩토링을 통해서 코드품질을 향상한다.<br>이 과정을 반복을 하는데, 추가요건이 생기거나 리팩토링을 통해서 소스가 변경되어 단위 테스트가 실패하면 이를 고치는 것은 자연스러운 과정이다.<br>물론 테스트를 유지보수하기 쉽게 작성하는 것이 중요하다. 어떻게 하면 유지보수하기 쉬운 테스트케이스를 작성할 수 있을까?</p><ul><li><p><strong>하나의 테스트에 하나의 기능만 검증하라.</strong></p><ul><li>SRP (Single Responsibility Principle, 단일책임의원칙)을 객체지향 개발에서 중요한 원칙으로 생각한다. 이는 테스트 작성에도 도움이 된다고 생각한다.</li><li>이를 유의하면서 테스트케이스를 작성하면 테스트 케이스의 수직거리가 짧기 때문에 훨씬 간결해진다.</li><li>하나의 테스트케이스에서 너무 많은 기능을 검증하려고 하면, 중간에 깨졌을때 어떤부분 때문에 깨졌는지 확인하는데 시간이 오래 걸리는 부작용을 낳는다.</li></ul></li><li><p><strong>테스트케이스에서 반복되는 부분도 리팩토링을 하라.</strong></p><ul><li>테스트케이스를 짜다보면 반복되는 부분들이 발생한다.</li><li>예를 들면 특정 상황을 만들기 위해서 반복해서 Mock객체에 Stub을 통해서 의도한 결과를 만드는 것이 필요한 경우, 부모클래스나 메소드로 분리하면 테스트 작성자는 테스트 짜는 것에만 집중할 수 있다.</li></ul></li></ul><p><img src="/images/unit-test-anti-pattern/tdd-life-cycle.png" alt="# TDD life cycle"></p><h4 id="Q-작성하는-방법을-잘-모르는데-러닝커브가-크지-않나"><a href="#Q-작성하는-방법을-잘-모르는데-러닝커브가-크지-않나" class="headerlink" title="Q. 작성하는 방법을 잘 모르는데 러닝커브가 크지 않나?"></a>Q. 작성하는 방법을 잘 모르는데 러닝커브가 크지 않나?</h4><p>초반에는 테스트케이스 작성하는 방법에 익숙하지 않기 때문에 분명히 시간이 든다. 테스트케이스 없이 개발할때 보다 시간이 더 오래 걸릴 것이다. 만약에 팀원들이아 리더가 코드 품질이나 테스트 케이스의 중요성에 대해서 인식하지 못하고 있다면 어떻게 해야할까?<br>사실 그런 상황속에서 개인의 노력과 희생으로 익숙해질때까지 버티는 것은 쉽지않다. </p><p>최소한 같은 팀이라면 코드 품질과 테스트의 중요성은 공감하고 있어야 한다. 그래야 나중에라도 생산성이 떨어지는 것 아니냐 등의 볼멘소리가 나오지 않는다.<br>Agile로 일하는 방식을 전파할때도 팀뿐만 아니라 리더들에게도 일하는 방식이나 사고방식의 변화의 중요성을 공유하는 이유가 그것 때문이다.<br>테스트케이스 작성에 익숙해지면 그 이후부터는 대부분 비슷한 경우의 반복이 많으며, 테스트케이스 작성때문에 생산성이 떨어지는 상황은 크게 문제가 되지 않았다.</p><ul><li><strong>잘 작성된 테스트케이스는 사전과 같다.</strong> 나중에 기억이 잘 안나면 찾아보고 작성하면 된다.<ul><li>단, 기존에 없었던 테스트를 작성해야 하는 상황에는 당연히 스파이킹 시간을 투자해야한다.</li><li>테스트케이스 자체가 문서라고 생각해보라. 물론 문서라는 것이 한번 만들고나면 현행화가 하는데 노력이 많이 들기도 하지만, 한번 만들어 놓으면 필요할때 찾아볼 수 있다.</li></ul></li><li>단위 테스트 작성에 익숙한 사람과 덜 익숙한 사람과 **페어프로그래밍(Pair Programming)**을 진행해보라.<ul><li>처음에는 익숙한 사람이 리딩을 하고, 그 이후에는 역할을 바꿔보며 페어로 진행하면 집중한 시간에 러닝커브를 가장 효율적으로 줄일 수 있다.</li><li>두 사람의 숙련도 차이가 너무 많이 나는 경우에는 차라리 교육으로 진행하는 것이 효율적이다.</li></ul></li></ul><h2 id="도입하기"><a href="#도입하기" class="headerlink" title="도입하기"></a>도입하기</h2><p>단위테스트의 장점도 알았고, 경험해보지 못해서 생긴 두려움도 어떻게 극복할 수 있을지 이야기해보았다. 그렇다면 당장 어떻게 팀에 도입할 수 있을까?<br>일단 팀원 모두가 공통적으로 필요성을 공감해야 지속할 수 있다. 기존에 프로젝트에 어떤 불편한점이 있었고, 단위테스트를 도입함으로써 어떻게 해결할 수 있을지 공감하고, 필요성을 느끼는 상태에서 시작해야 오래갈 수 있다.<br>팀원에 한명이라도 부정적인 생각을 가지고 있다면, 그 사람은 테스트케이스 짜기를 앞으로도 꺼려해 누군가가 또 비는 곳을 채우는 상황들이 벌어질 수 있기 때문이다.<br>기존에 작성하지 않는 팀이 도입하기 위해서는 어떤 변화가 필요할까?</p><ul><li>PM은 테스트케이스 작성에 개발자들이 익숙해지기까지 팀의 Velocity가 당장 떨어질 수 있다는 것을 인지해야 한다.<ul><li>팀의 Velocity가 올라올때 까지 얼마나 걸릴지 확인해야하고, 그것을 감안해 일의 우선순의를 정리할 수 있어야 한다.</li><li>작성에 익숙해지면 그 이후부터는 개발하는 과정일 뿐이지 Velocity가 떨어지는 등의 일은 발생하지 않을 것이다.</li></ul></li><li>테스트케이스 작성의 원칙, 범위, 작성방법을 정하고 시작한다.<ul><li>개발자들마다 개발하는 스타일이 다 다를지라도, 소스의 유지보수를 위해서 표준, 코드 컨벤션 등의 스타일을 맞추는 작업을 진행한다.</li><li>테스트케이스의 유지보수를 위해서 얼마나 간결하게 작성을 할 것인지 범위를 정하는 것과 어떤 assertion이나 matcher 도구 등을 사용할지 정하고 가야 작성법이 단순해지기 전에 유지보수하기 편하다.<br> (예: junit + hamcrest matcher vs assertJ)</li><li>테스트케이스 작성법이나 원칙은 계속 개선해나가는 것이 좋다. 단 변경될때마다 팀원들과 적극적으로 공유해야 테스트케이스 작성법을 비슷한 수준으로 유지할 수 있다.</li></ul></li></ul><h2 id="단위테스트-작성원칙"><a href="#단위테스트-작성원칙" class="headerlink" title="단위테스트 작성원칙"></a>단위테스트 작성원칙</h2><blockquote><h4 id="하나의-테스트케이스에-최소한의-기능만-검증하고-최대한-간결하게-짠다"><a href="#하나의-테스트케이스에-최소한의-기능만-검증하고-최대한-간결하게-짠다" class="headerlink" title="하나의 테스트케이스에 최소한의 기능만 검증하고, 최대한 간결하게 짠다."></a><strong>하나의 테스트케이스에 최소한의 기능만 검증하고, 최대한 간결하게 짠다.</strong></h4></blockquote><ul><li>테스트케이스가 많은 것은 큰 문제가 되지 않는다. IDE 툴을 사용하면 테스트케이스가 많은 것은 쉽게 찾을 수 있다.</li><li>[안티패턴] Java를 예를들면, 클래스에서 하나의 메소드를 하나의 테스트케이스를 기준으로 작성하는 경우를 본적이 있다. 분기문이 있거나 exception을 발생하는 경우가 다 하나의 테스트케이스에 포함되어 있다면 유지보수가 너무 어렵다.</li><li>소스를 변경해서 테스트케이스를 고치야 하는 경우, 테스트케이스를 이해하기위해서 시간을 많이 든다면 얼마나 비효율적인가? 유지보수하기 편하게 작성하는 것이 중요하다.</li></ul><blockquote><h4 id="입력값에-대한-결과-값을-검증하는-방식으로-짜는-것이-기본이다"><a href="#입력값에-대한-결과-값을-검증하는-방식으로-짜는-것이-기본이다" class="headerlink" title="입력값에 대한 결과 값을 검증하는 방식으로 짜는 것이 기본이다."></a><strong>입력값에 대한 결과 값을 검증하는 방식으로 짜는 것이 기본이다.</strong></h4></blockquote><ul><li>입력값에 대한 결과값을 확인하는 방식으로 작성하면 소스가 변경되더라도 테스트케이스를 변경할 일이 훨씬 적다.</li><li>테스트케이스를 작성하다보면 구현체에 의존하지 않는 테스트케이스를 작성해야 유지보수가 쉽다. 하지만 단위테스트는 Mock객체를 사용하고 때로는 Stubbing도 해야되기 때문에 어느정도 구현체에 의존적일 수 밖에 없다.<br>하지만 구현체에 의존적이지 않아야 유지보수 노력이 덜 든다.</li><li>항상 옳은 방법은 아닐 수 있지만, 기본적으로는 입력 값대비 결과값을 검증하는 방식으로 테스트케이스를 작성한다고 생각하면 쉽다.</li><li>Java에서 단위 테스트에서 Private이나 Static method에 stub을 하기 위해 PowerMock을 사용하는 경우가 있다. 물론 File 관련 테스트를 작성하는 경우에 PowerMock이 도움이 된다.<br>하지만 정말 복잡하거나 필요한 경우가 아니라면 PowerMock을 도입하는 것보다, 입력값에 대한 결과값을 확인하는 방식으로 작성하라.</li></ul><blockquote><h4 id="불안한-부분이-없도록-개발하는-부분은-최대한-커버하라"><a href="#불안한-부분이-없도록-개발하는-부분은-최대한-커버하라" class="headerlink" title="불안한 부분이 없도록, 개발하는 부분은 최대한 커버하라."></a><strong>불안한 부분이 없도록, 개발하는 부분은 최대한 커버하라.</strong></h4></blockquote><ul><li>우리가 개발하는 부분은 최대한 꼼꼼하게 작성해야 테스트케이스의 효과를 최대한 얻을 수 있다. 촘촘한 그물로 물고기를 많이 잡을 수 있는 것과 비슷하다.</li><li>커버리지는 꼼꼼하게 단위테스트를 작성하면 따라온다. 커버리지 수치 자체가 목적이 되어서는 안된다.</li></ul><blockquote><h4 id="Third-Party-Library의-기능은-믿고-검증대상에서-제외하라"><a href="#Third-Party-Library의-기능은-믿고-검증대상에서-제외하라" class="headerlink" title="Third Party Library의 기능은 믿고, 검증대상에서 제외하라."></a><strong>Third Party Library의 기능은 믿고, 검증대상에서 제외하라.</strong></h4></blockquote><ul><li>효율적인 개발을 위해 적용한 라이브러리 또는 플러그인의 기능은 정상적으로 동작할거라 믿고 검증하지 않는다.</li><li><strong>그럼에도 중요한 기능이고 테스트가 없어서 커버하지 못한다, Unit Test외에 Integration Test나 다른 테스트로 검증을 하는 것도 고려해본다.</strong></li><li>예를들어, Spring에서 JPA, Mybatis 등을 사용하는데 Query의 기능을 검증하고 싶은 경우가 있다. 단위테스트를 위해 라이브러리 내부에서 동작하는 방식을 확인하면서 Mock객체로 바꾸고, Stub하는 과정은 상당히 괴롭다.<br>이런 경우 Embedded DB나 Test DB를 대상으로 Repository Test 또는 Integration Test를 하는 것이 효율적이다.</li></ul><p>단위테스트를 힘들게 드디어 팀에 도입했다. 시작이 반이라고는 하지만 이제부터가 진짜 중요하다. 어떻게 하면 힘들게 도입하게된 단위 테스트의 장점을 만끽하면서 지속할 수 있을까?<br>테스트케이스를 작성하면서 개발을 시작했는데, 코드의 변경이 없어서 테스트케이스를 왜 작성해야하는지 모르겠다고 한다. 그냥 일만 두배로 하는 기분이고 이게 어떤 장점이 있는지 모르겠다고 한다.<br>물론 기능이 동작하는 것이 가장 중요하지만, 한번 작성한 코드를 개선하는 노력없이 그대로 계속 둔다는 것은 충격적이다. </p><h2 id="단위테스트를-지속하기-위한-방법"><a href="#단위테스트를-지속하기-위한-방법" class="headerlink" title="단위테스트를 지속하기 위한 방법"></a>단위테스트를 지속하기 위한 방법</h2><h4 id="Refactoring-x3D-지속하는-원동력"><a href="#Refactoring-x3D-지속하는-원동력" class="headerlink" title="Refactoring &#x3D; 지속하는 원동력"></a>Refactoring &#x3D; 지속하는 원동력</h4><p>개인적으로는 내가 작성한 코드가 되었던 내가 만드는 제품은 살아있는 생명체라 생각한다. 더 이상 관심을 두지않고, 그대로 둔다면 그냥 죽어있는 거다. 현실은 변경이 있을때마다 누더기처럼 덕지덕지 코드가 붙고, 그러다보니 기존에 만들어진 구조에서 최소한의 변경만 하려고 한다.<br>이런 상황을 포장해서 고급스럽게(?) 레거시 프로그램이기 때문에 어쩔 수 없다고 말하는 사람들을 만나면 복잡한 생각이 든다.</p><p>리팩토링의 장점은 정말 크다고 생각한다. 내가 하고 있는 일, 내가 만드는 것들에 대해 가치를 불어넣어주는 중요한 행위라 생각한다. 리팩토링이 성공했다는 보장이 기존의 테스트케이스 통과이기 때문에, 꼼꼼한 테스트케이스가 있을수록 더 나은 코드로 개선할 수 있는 기회가 많다는 것이다.<br>그래서 기존에 테스트케이스 효과를 경험하지 못한분들과 페어를 할 때는 유저스토리를 하나하면 리팩토링을 하나하는 순으로 일을 하려한다. 우리가 만든 코드를 개선하면서 바로 작성한 테스트케이스가 효과가 있는 것을 경험하는 과정이 말보다 훨씬 공감하기 좋은 방법이었다.</p><p><strong>리팩토링을 습관화하기 위한 좋은 방법은 페어프로그래밍이 있지만 현실적 여건상 하기 어려운 곳들도 있다. 그런 경우에는 코드리뷰를 적용해보라.</strong> 코드리뷰를 통해서 더 나은 코드를 눈으로 보고, 내가 만드는 코드들이 더 나은 모습으로 개선될 수 있다는 것을 알게되면 자연스레 어느 정도의 코드품질을 지키기위해 리팩토링을 하게된다.</p><p><img src="https://ih0.redbubble.net/image.543237740.8590/flat,1000x1000,075,f.jpg" alt="# 리팩토링은 사랑입니다."></p><h4 id="테스트-자동화"><a href="#테스트-자동화" class="headerlink" title="테스트 자동화"></a>테스트 자동화</h4><p>테스트 자동화는 딜리버리 가능한 제품을 만들기 위해서는 선택이 아니라 필수다. 테스트 커버리지 측정, Report 생성해주는 라이브러리들, Sonar, Build Monitor를 이용해서 눈으로 우리가 만들고 있는 제품의 상황을 확인할 수 있다.</p><p>테스트케이스를 작성하는 목적보다 수치에 집착하는 것은 옳지 않다. <strong>빌드 모니터의 목적은 눈으로 문제를 바로 확인할 수 있기 때문에, 가장 빠르게 대처하기 위함이다.</strong> 특히 사람은 눈에 보이는 것들에 민감하게 반응한다. 코드 커버리지나 코드 스멜, 보안성 취약점 등이 눈으로 확인되면 개선을 하려고 한다.<br>그리고 한번 지켜지는 코드품질의 수준 이하로 내려가는 경우는 드물다.</p><p><img src="/images/unit-test-anti-pattern/build-monitor.png" alt="# Build Monitor"><br><img src="/images/unit-test-anti-pattern/sonar.png" alt="# Sonar Coverage"></p><h2 id="결론"><a href="#결론" class="headerlink" title="결론"></a>결론</h2><p>이번 글은 개인적으로 프로젝트에 단위 테스트를 전파했던 경험들에 기반한 내용으로 개인적인 경험에 기반한 내용이라 부족하거나, 혹시 잘못된 생각이 있을 수도 있습니다.</p><p>처음에 단위테스트와 TDD를 프로젝트에서 하고 싶은데 방법을 몰라서 그만두게 된적이 몇번 있었다. 그 이후에 방법을 알고 싶어서 지금 부서에 와서 일을 하게 되었고, 이 글이 저와 비슷한 상황을 겪는 분들께 도움이 되었으면 합니다.<br>지금의 저는 부족하면 더 많은 테스트케이스를 짜려고 합니다. 단위테스트로 부족하다고 생각이 들면 다른 테스트를 통해서 커버할 수 있는 방법이 있는지 고민합니다. 서비스를 만들다보면 소스가 자주 변화는 경우도 많고, 오늘의 나는 어제의 내가 짠 소스를 보면서 이해못하는 순간이 많습니다.<br>그런 상황에서 믿을 것은 동료도 있지만 꼼꼼하게 작성한 테스트케이스가 큰 의지가 됩니다.</p><p>사람은 한번 더 편안한 것을 알게되면 이전에 구린방식으로 돌아가긴 어렵습니다. 제게 단위테스트가 그랬습니다. 만약에 이 글을 읽고 궁금한 점이 있으시면 댓글로 남겨주시면 확인하는대로 답변드리겠습니다. </p>]]></content:encoded>
      
      
      <category domain="http://gregor77.github.io/categories/Unit-Test-TDD/">Unit Test &amp; TDD</category>
      
      
      <category domain="http://gregor77.github.io/tags/Unit-test/">Unit test</category>
      
      <category domain="http://gregor77.github.io/tags/%EB%8B%A8%EC%9C%84%ED%85%8C%EC%8A%A4%ED%8A%B8/">단위테스트</category>
      
      <category domain="http://gregor77.github.io/tags/Unit-Test-Anti-Pattern/">Unit Test Anti Pattern</category>
      
      <category domain="http://gregor77.github.io/tags/TDD/">TDD</category>
      
      <category domain="http://gregor77.github.io/tags/%EB%8B%A8%EC%9C%84-%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%8B%A4%ED%8C%A8/">단위 테스트 실패</category>
      
      
      <comments>http://gregor77.github.io/2019/08/16/about-unit-test/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Spring - 내가 짜는 Controller Test가 Hybrid Test?</title>
      <link>http://gregor77.github.io/2019/08/13/spring-hybrid-test/</link>
      <guid>http://gregor77.github.io/2019/08/13/spring-hybrid-test/</guid>
      <pubDate>Tue, 13 Aug 2019 10:24:31 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;Spring 기반에서 Controller 테스트를 작성시 요청을 보내고, 응답을 확인하는 형태로 많이 작성한다.&lt;br&gt;그러다 보니 MockMvc나 jsonPath를 조합해서 Controller 테스트를 작성하는 경우가 많다.&lt;br&gt;이번 포스팅은 </description>
        
      
      
      
      <content:encoded><![CDATA[<p>Spring 기반에서 Controller 테스트를 작성시 요청을 보내고, 응답을 확인하는 형태로 많이 작성한다.<br>그러다 보니 MockMvc나 jsonPath를 조합해서 Controller 테스트를 작성하는 경우가 많다.<br>이번 포스팅은 MockMvc 기반의 Controller 테스트 작성방식을 다른 관점에서 볼 수 있는 경험담이다.</p><h2 id="1-Hybrid-Testing"><a href="#1-Hybrid-Testing" class="headerlink" title="1. Hybrid Testing?"></a>1. Hybrid Testing?</h2><p>Thought works에서 일하다 과거 같이 일하게 된 Kris가 프로젝트에 작성된 테스트케이스들에 대해 코드리뷰 해준 경험이 있다.<br>기존의 Controller 테스트는 MockMvc를 이용해서 요청을 보내고 응답을 받는 방식으로 테스트 케이스를 작성하고 있었다.<br>그런데 Kris가 너희가 짜고 있는 Controller 테스트는 Hybrid Test에 가깝다는 말을 했다.<br>그리고 Controller 테스트를 pure한 Unit 테스트로 바꿔보는 것이 어떠겠냐고 제안을 했다.</p><h4 id="Hybrid-Testing-정의"><a href="#Hybrid-Testing-정의" class="headerlink" title="Hybrid Testing 정의"></a><a href="https://www.h2kinfosys.com/blog/hybrid-testing/">Hybrid Testing</a> 정의</h4><p>Hybrid 테스트라는 단어를 들었을때, 단순히 어휘만 보고 뜻을 유추할 뿐 어떤 의미인지 정확하게 알지 못했다. 영어가 짧아 Kris와 깊은 대화를 하지 못했지만, 정의를 보고 어떤 의미에서 그렇게 말했는지 유추해보았다.<br>첨부한 주소에 있는 내용을 기반으로 “Hybrid Testing”에 대해 정리를 해보았다.</p><p><img src="/images/hybrid-test/Hybrid-Testing.svg" alt="#Hybrid Testing의 정의"></p><ul><li>하이브리드 테스트는 하향식 및 상향식 접근 방식의 장점을 사용하며, 테스트는 두 기술을 모두 사용해서 수행한다.</li><li>레이어 구성 &#x3D; 상위 레이어 + 기본 대상 레이어 + 하위 레이어</li><li>테스트는 중간 레벨 대상 계층에 중점을 두고 진행한다.</li></ul><h4 id="장점"><a href="#장점" class="headerlink" title="장점"></a>장점</h4><ul><li>개발주기의 초기 단계에서 기본적으로 동작하는 시스템을 만들수 있도록, 가능한 빨리 동작하는 버전의 프로그램을 테스트하고 싶은 경우 채택한다.</li><li>코드 커버리지의 정확성이 증가되고, 정기적인 시간 간격을 두고 최소의 테스트 케이스를 생성한다.</li></ul><h4 id="테스트할-내용"><a href="#테스트할-내용" class="headerlink" title="테스트할 내용"></a>테스트할 내용</h4><ul><li>기능 테스트: 모든 기능이 예상대로 작동하는지 확인</li><li>호환성 테스트</li><li>연결 테스트: 응용 프로그램이 여러 유형의 네트워크 연결에서 올바르게 작동하는지 확인</li></ul><h2 id="2-Spring-Controller-Test"><a href="#2-Spring-Controller-Test" class="headerlink" title="2. Spring Controller Test"></a>2. Spring Controller Test</h2><p>Spring MVC에서 MockMvc를 이용하여 Controller 테스트를 작성하는 방식이 왜 Hybrid 테스트가 되는지 확인해보자.<br><img src="/images/hybrid-test/Spring-Mvc.svg" alt="#Spring MVC"> </p><h4 id="테스트-범위"><a href="#테스트-범위" class="headerlink" title="테스트 범위"></a>테스트 범위</h4><ul><li>실제로 테스트를 하려고 하는 대상(subject)는 컨트롤러의 로직이다.</li><li>테스트를 동작방식이 상위 레이어를 통과하고, 하위 레이어를 다 통과해서 테스트를 한다.<ul><li>SpringRunner를 통해서 아래의 어노테이션과 함께 테스트를 수행한다</li><li>@SpringBootTest : 전체 Application Context 로드가 필요한 경우</li><li>@WebMvcTest: 컨트롤러에 필요한 Context만 필요한 경우</li></ul></li><li>상위 레이어<ul><li>Filter, Interceptor, DispatcherServlet 포함한 Front controller 수행</li><li>Request의 항목을 Object로 Deserialize 수행</li><li>하위 레이어를 거친 결과가 Response로 리턴 (response body, statusCode를 체크한다)</li></ul></li><li>하위 레이어<ul><li>Controller에서 호출하는 Service 또는 Repository를 포함한 DI(Dependency Injection)를 통<br>해서 사용하는 Bean객체들은 @MockBean 어노테이션을 통해서 Mock 객체로 사용</li><li>필요한 경우 Mock 객체에 Method의 호출 결과를 의도한 결과로 동작하게끔 준비한다. (Stub &#x3D;&#x3D; canned answer)</li></ul></li></ul><h4 id="장점-1"><a href="#장점-1" class="headerlink" title="장점"></a>장점</h4><ul><li>검증하고자 하는 부분은 Controller 로직이지만, API가 실제 동작하는 방식으로 체크를 하기 때문에 테스트 정확도가 더 높다. </li><li>개발단계에서 Test Case를 작성하고 수행함으로써 오류를 미리 파악하다.<br>(여기서 미리 파악 가능하다는 것은, 로컬에서 어플리케이션을 수행하거나, 배포하기 전에 파악이 가능한 것을 의미한다)</li></ul><h2 id="Functional-Test-도입"><a href="#Functional-Test-도입" class="headerlink" title="Functional Test 도입"></a>Functional Test 도입</h2><p>부르는 명칭이 조금씩 다르기는 했지만 Integration Test, API Test, Functional Test라 불렀던 것 같다.<br>물론 각 명칭마다 조금씩 차이가 있을 수 있지만 동작방식은 API 요청을 보내고, 실제 비지니스 로직과 DB를 거친 결과를 확인하는 방식이다.<br><strong>Functional Test와 Unit Test는 작성하는 목적은 다르고, 지속하기 위해서는 상당한 노력이 필요하다.</strong></p><ul><li>데이터 유효성 처리<ul><li>Embedded DB를 도입하던가 @Transactional을 통해 데이터 유효성을 유지하던가등 Unit Test를 작성할때 하지 않았던 것들을 고민해야한다.</li></ul></li><li>쉽게 테스트 작성하기<ul><li>MockMvc와 jsonPath를 이용해 Functional Test를 작성하기 위해서는 입력값과 결과값을 작성하기 번거롭다.</li><li>테스트를 지속적으로 작성하기 위해서는 작성이 쉬워야 하며, Functional Test의 경우 입력과 결과값을 최대한 단순하게 작성하는 것이 도움이 된다.</li><li><a href="http://rest-assured.io/">Rest Assured</a>를 개인적으로 추천한다. Request와 Response를 json 기반으로 작성이 가능하<br>고, 그 기반으로 Response 검증이 가능하다.</li></ul></li></ul><h4 id="Functional-Test-vs-Hybrid-Controller-Test"><a href="#Functional-Test-vs-Hybrid-Controller-Test" class="headerlink" title="Functional Test vs Hybrid Controller Test"></a>Functional Test vs Hybrid Controller Test</h4><p>팀의 성숙도와 상황에 따라 Controller Test를 어떻게 작성할 것인지 결정하면 될 것 같다.<br>이는 개인적인 경험에 따른 판단이기 때문에 다른분과 의견이 다를 수도 있습니다.</p><ul><li><p>Hybrid Controller Test 언제 적합할까?</p><ul><li>기존의 MockMvc를 통한 Controller Test 수행하면, 상위 레이어와 하위 레이어 검증이 가능하다.</li><li>팀의 규모가 작은 경우</li><li>팀의 테스트 케이스 작성 및 유지보수의 성숙도가 낮은 경우</li><li>비지니스 로직이 단순하거나, API의 값 검증의 가성비가 낮은 경우</li><li>기존의 테스트 방식으로 비슷한 효과를 낼 수 있기 때문에 유지하는 것이 현실적일 수 있다.</li></ul></li><li><p>Functional Test 도입 + Controller Test를 Unit Test로 변경은 언제 적합할까?</p><ul><li>Functional Test를 도입하면 상위 레이어의 기능 검증은 Functional Test로 위임이 가능하고,<br>기존 Controller Test처럼 중복해서 검증할 필요없기 때문에 Pure한 Unit Test를 작성할 수 있다.</li><li>이말은 Controller 테스트또한 Service 테스트처럼, ApplicationContext를 생성할 필요없이<br> MockitoRunner를 이용해서 테스트 작성이 가능한 것을 의미한다.</li><li>실제 API의 결과를 검증하는 것이기 때문에 비지니스 로직과 DB를 거친 값을 검증한다.</li><li>API의 비지니스 로직이 복잡하고, API의 값 검증이 중요한 경우</li><li>팀의 규모가 어느 정도되고, 테스트 케이스 작성 및 유지보수의 성숙도가 큰 경우</li></ul></li></ul><h4 id="결론"><a href="#결론" class="headerlink" title="결론"></a>결론</h4><p>Kris의 제안대로 기존의 Controller Test 검증방식 중, 상위 레이어의 검증 대상을 Functional Test<br>로 위임하고, 기존의 Controller 테스트를 Service 테스트처럼 작성하는 것이 옳은 것일까?<br>결론은 <strong>테스트케이스를 작성하고 유지하는 팀의 성숙도에 따라 결정하면 될 것 같다.</strong> 또한 팀원들이<br>기존의 테스트가 커버하지 못하는 부분이 있어 불안함과 부족함을 느낀다면 그때 시도해보는 것도 추천한다.</p>]]></content:encoded>
      
      
      <category domain="http://gregor77.github.io/categories/Unit-Test-TDD/">Unit Test &amp; TDD</category>
      
      <category domain="http://gregor77.github.io/categories/Unit-Test-TDD/Spring/">Spring</category>
      
      
      <category domain="http://gregor77.github.io/tags/Unit-test/">Unit test</category>
      
      <category domain="http://gregor77.github.io/tags/%EB%8B%A8%EC%9C%84%ED%85%8C%EC%8A%A4%ED%8A%B8/">단위테스트</category>
      
      <category domain="http://gregor77.github.io/tags/TDD/">TDD</category>
      
      <category domain="http://gregor77.github.io/tags/Spring/">Spring</category>
      
      <category domain="http://gregor77.github.io/tags/Controller-Test/">Controller Test</category>
      
      <category domain="http://gregor77.github.io/tags/Hybrid-Test/">Hybrid Test</category>
      
      
      <comments>http://gregor77.github.io/2019/08/13/spring-hybrid-test/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Hexo 기반의 Github 개발자 블로그 만들기</title>
      <link>http://gregor77.github.io/2019/08/12/hexo-github-blog/</link>
      <guid>http://gregor77.github.io/2019/08/12/hexo-github-blog/</guid>
      <pubDate>Mon, 12 Aug 2019 01:58:31 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;Github으로 개발자 블로그를 생성하려고 하니 Hexo와 Jekyll 중에 어떤 툴을 사용해서 만들지 고민이었다.&lt;br&gt;처음에는 Jekyll로 했는데 커스터마이징을 하려고하니 ruby보다는 javascript가 낫겠다 싶어 Hexo로 바꾸었다.</description>
        
      
      
      
      <content:encoded><![CDATA[<p>Github으로 개발자 블로그를 생성하려고 하니 Hexo와 Jekyll 중에 어떤 툴을 사용해서 만들지 고민이었다.<br>처음에는 Jekyll로 했는데 커스터마이징을 하려고하니 ruby보다는 javascript가 낫겠다 싶어 Hexo로 바꾸었다.<br>둘다 사용해봤는데 둘다 장점은 비슷한 것 같고, 개인의 취향대로 하고 싶은 것을 선택하면 될 것 같다. </p><h2 id="Hexo-설치"><a href="#Hexo-설치" class="headerlink" title="Hexo 설치"></a>Hexo 설치</h2><p>Hexo 설치후, 사용하고자 하는 themes를 선택한다.<br>처음에는 landscape 테마를 선택했다가 comments, 찾기 기능이 있는 hueman 테마로 변경했다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init</span><br><span class="line">$ hexo new post &#123;post name&#125;</span><br><span class="line">$ hexo generate</span><br><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p><img src="/images/hexo-github-blog/hexo-logo.png" alt="Hexo logo 이미지"></p><h4 id="theme-적용하기"><a href="#theme-적용하기" class="headerlink" title="theme 적용하기"></a>theme 적용하기</h4><ol><li>Hexo 사이트에 theme 메뉴에서 마음에 드는 테마를 선택 후, blog repository 내부로 새로운 theme를 clone<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> &#123;&#123;theme github repository 주소&#125;&#125; themes/&#123;&#123;새로운theme명&#125;&#125;</span><br><span class="line"> </span><br><span class="line">예)</span><br><span class="line">$ git <span class="built_in">clone</span> https://github.com/ppoffice/hexo-theme-hueman.git themes/hueman</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li>_config.yml에서 theme 값 변경<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">themem:</span> <span class="string">hueman</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><h2 id="할일"><a href="#할일" class="headerlink" title="할일"></a>할일</h2><ol><li>구글 사이트 등록과 검색엔진 최적화</li><li>네이버 사이트 등록과 검색엔진 최적화</li><li>Open graph tag 적용</li><li>화면 update</li></ol><ul><li>배경 이미지 변경</li><li>사용하지 않는 메뉴 비활성화 (ex. NUBE DE TAGS)</li></ul><h2 id="참조-블로그"><a href="#참조-블로그" class="headerlink" title="참조 블로그"></a>참조 블로그</h2><p>블로그에 글이 너무 잘 작성되어 있어서, 아래 블로그를 따라하면서 적용함</p><ul><li><a href="https://hexo.io/ko/docs/index.html">Hexo document</a></li><li><a href="https://futurecreator.github.io/2016/06/15/hexo-google-site-search-console-analytics/">구글 사이트 등록과 검색엔진 최적화(SEO)</a></li><li><a href="https://futurecreator.github.io/2016/06/15/hexo-naver-search-webmaster/">네이버 사이트 등록과 검색엔진 최적화(SEO)</a></li></ul>]]></content:encoded>
      
      
      <category domain="http://gregor77.github.io/categories/Blog/">Blog</category>
      
      
      <category domain="http://gregor77.github.io/tags/Hexo/">Hexo</category>
      
      <category domain="http://gregor77.github.io/tags/Github-blog/">Github blog</category>
      
      <category domain="http://gregor77.github.io/tags/SEO/">SEO</category>
      
      <category domain="http://gregor77.github.io/tags/Google-Analytics/">Google Analytics</category>
      
      <category domain="http://gregor77.github.io/tags/Google-Search-Console/">Google Search Console</category>
      
      
      <comments>http://gregor77.github.io/2019/08/12/hexo-github-blog/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Docker 개념과 실습</title>
      <link>http://gregor77.github.io/2019/03/19/docker-basic/</link>
      <guid>http://gregor77.github.io/2019/03/19/docker-basic/</guid>
      <pubDate>Tue, 19 Mar 2019 13:24:31 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;Docker-기초&quot;&gt;&lt;a href=&quot;#Docker-기초&quot; class=&quot;headerlink&quot; title=&quot;Docker 기초&quot;&gt;&lt;/a&gt;Docker 기초&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;Docker에 대한 기본 설명과 Mac에서 실습을 진행하기 위</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="Docker-기초"><a href="#Docker-기초" class="headerlink" title="Docker 기초"></a>Docker 기초</h2><p><strong>Docker에 대한 기본 설명과 Mac에서 실습을 진행하기 위한 글이다.</strong><br>마지막에 nginx.conf 설명이 있는 이유는, 프론트 소스를 빌드 결과를 nginx에 index.html 디렉토리 하위<br>에 복사 후 nginx 도커 이미지 기반으로 app이 동작하는 것을 확인하는 것을 실습의 목표로 한다.</p><h2 id="VM-vs-Container"><a href="#VM-vs-Container" class="headerlink" title="VM vs Container"></a>VM vs Container</h2><ul><li>vm은 OS가 동작하는데 필요한 기능들을 guest OS로 들고 있어야 한다. 용량이 크다.</li><li>vm은 io가 발생하는 경로가 container보다 많다.</li><li>vm이 처리한 io를 결국 host os의 커널이 받아 자신의 드라이버에 맞게 처리 필요하다. (병목 발생)</li><li>container는 host의 os를 공유한다.<br><img src="https://images.idgesg.net/images/article/2017/06/virtualmachines-vs-containers-100727624-large.jpg" alt="# VM 와 Container"><br><img src="https://tech.ssut.me/content/images/2017/08/docker_benchmarks.jpg" alt="# VM vs Container 성능 비교"></li></ul><h2 id="Linux-kernel-features"><a href="#Linux-kernel-features" class="headerlink" title="Linux kernel features"></a>Linux kernel features</h2><h4 id="namespaces"><a href="#namespaces" class="headerlink" title="namespaces"></a>namespaces</h4><ul><li>mnt (파일시스템 마운트) : 호스트 파일 시스템에 구애받지 않고 독립적으로 파일 시스템을 마운트하거나 언마운트 가능</li><li>pid</li><li>net : namespace간 네트워크 충돌 방지 (ex. 중복포트 바인딩)</li><li>ipc : 프로세스간 독립적인 통신통로 할당</li><li>uts (hostname)</li><li>user (UID)</li></ul><h4 id="cgroup-Control-groups"><a href="#cgroup-Control-groups" class="headerlink" title="cgroup (Control groups)"></a>cgroup (Control groups)</h4><p>자원에 대한 제어를 가능하게 해준다.</p><ul><li>메모리, CPU, I&#x2F;O, 네트워크, device 노드(&#x2F;dev)</li></ul><h2 id="장점"><a href="#장점" class="headerlink" title="장점"></a>장점</h2><ul><li>운영환경과 동일한 환경으로 개발환경 구성이 가능하다.</li><li>Orchestration &#x3D;&gt; scale out</li><li>MSA에 적합</li></ul><h2 id="Mac-환경설정"><a href="#Mac-환경설정" class="headerlink" title="Mac 환경설정"></a>Mac 환경설정</h2><ul><li>docker desktop app 설치 및 구동확인  (맥에서 가상화환경을 사용하기 위해 도커 엔진 설치)<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker version</span><br><span class="line"></span><br><span class="line"># -i: tty 모드, -t: 대화형 세션, -h: host명</span><br><span class="line">$ docker exec -it redis bash</span><br></pre></td></tr></table></figure></li></ul><h2 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h2><ul><li>도커 이미지를 생성하기 위한 절차를 담고 있는 텍스트 파일</li><li>교육 중 진행한 <a href="https://github.com/x-change/sample">sample 프로젝트</a>를 docker 컨테이너로 실행해보자.<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#Dockerfile: sample project</span><br><span class="line">FROM nginx:alpine</span><br><span class="line"></span><br><span class="line">COPY nginx.conf /etc/nginx/conf.d/default.conf</span><br><span class="line"></span><br><span class="line">COPY ./dist/ /usr/share/nginx/html</span><br><span class="line"></span><br><span class="line">#로컬에 image file 생성 [name]:[tag]</span><br><span class="line">$docker build -t sample .</span><br></pre></td></tr></table></figure></li></ul><h2 id="Docker-image"><a href="#Docker-image" class="headerlink" title="Docker image"></a>Docker image</h2><ul><li>여러 계층으로 구성되어 있다.</li><li>각 계층은 읽기 전용 파일 시스템에 있다.</li><li>계층은 도커파일에 있는 명령마다 생성되며, 이전 계층 위에 위치하게 된다.<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$docker images</span><br><span class="line"></span><br><span class="line">$docker rmi [이미지명]</span><br><span class="line"></span><br><span class="line">## UFS (유니온 파일 시스템, 유니온 마운트), 여러 개의 파일 시스템을 겹칠 수 있도록 해준다.</span><br><span class="line">$docker info | grep &quot;Storage Driver&quot;</span><br></pre></td></tr></table></figure></li></ul><h2 id="Docker-Registry"><a href="#Docker-Registry" class="headerlink" title="Docker Registry"></a>Docker Registry</h2><p>이미지를 운영하고 배포하는 역할을 담당하는 서비스, 기본 레지스트리 도커 허브</p><ul><li>docker hub</li><li>private registry</li></ul><h2 id="Container"><a href="#Container" class="headerlink" title="Container"></a>Container</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">## 많이 사용하는 command 기준으로 설명</span><br><span class="line">$docker run -h sample-web -p 9080:80 -d sample</span><br><span class="line"></span><br><span class="line">$docker ps</span><br><span class="line"></span><br><span class="line">$docker stop [컨테이너명 | 컨테이너 ID]</span><br><span class="line"></span><br><span class="line">$docker ps -a</span><br><span class="line"></span><br><span class="line">$docker start [컨테이너명 | 컨테이너 ID]</span><br><span class="line"></span><br><span class="line">$docker rm [컨테이너명 | 컨테이너 ID]</span><br></pre></td></tr></table></figure><h2 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h2><ul><li><a href="https://medium.com/@darkrasid/docker%EC%99%80-vm-d95d60e56fdd">Docker와 VM</a></li><li><a href="https://tech.ssut.me/what-even-is-a-container/">Docker의 작동원리</a></li><li><a href="https://www.infoworld.com/article/3204171/what-is-docker-docker-containers-explained.html">What is Docker?</a></li><li><a href="https://www.infoworld.com/article/3310941/why-you-should-use-docker-and-containers.html">Why you should use docker?</a></li></ul><h2 id="설정"><a href="#설정" class="headerlink" title="설정"></a>설정</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">#nginx.conf</span><br><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  localhost;</span><br><span class="line"></span><br><span class="line">    #charset koi8-r;</span><br><span class="line">    #access_log  /var/log/nginx/host.access.log  main;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        if (!-e $request_filename)&#123;</span><br><span class="line">            rewrite ^(.*)$ /index.html break;</span><br><span class="line">        &#125;</span><br><span class="line">        root   /usr/share/nginx/html;</span><br><span class="line">        index  index.html index.htm;</span><br><span class="line">        gzip_static on;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    #error_page  404              /404.html;</span><br><span class="line"></span><br><span class="line">    # redirect server error pages to the static page /50x.html</span><br><span class="line">    #</span><br><span class="line">    error_page   500 502 503 504  /50x.html;</span><br><span class="line">    location = /50x.html &#123;</span><br><span class="line">        root   /usr/share/nginx/html;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    # proxy the PHP scripts to Apache listening on 127.0.0.1:80</span><br><span class="line">    #</span><br><span class="line">    #location ~ \.php$ &#123;</span><br><span class="line">    #    proxy_pass   http://127.0.0.1;</span><br><span class="line">    #&#125;</span><br><span class="line">    location /api/v1 &#123;</span><br><span class="line">        proxy_pass  http://127.0.0.1:8088;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000</span><br><span class="line">    #</span><br><span class="line">    #location ~ \.php$ &#123;</span><br><span class="line">    #    root           html;</span><br><span class="line">    #    fastcgi_pass   127.0.0.1:9000;</span><br><span class="line">    #    fastcgi_index  index.php;</span><br><span class="line">    #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;</span><br><span class="line">    #    include        fastcgi_params;</span><br><span class="line">    #&#125;</span><br><span class="line"></span><br><span class="line">    # deny access to .htaccess files, if Apache&#x27;s document root</span><br><span class="line">    # concurs with nginx&#x27;s one</span><br><span class="line">    #</span><br><span class="line">    #location ~ /\.ht &#123;</span><br><span class="line">    #    deny  all;</span><br><span class="line">    #&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://gregor77.github.io/categories/Docker/">Docker</category>
      
      
      <category domain="http://gregor77.github.io/tags/Docker/">Docker</category>
      
      <category domain="http://gregor77.github.io/tags/Docker-%EC%8B%A4%EC%8A%B5/">Docker 실습</category>
      
      
      <comments>http://gregor77.github.io/2019/03/19/docker-basic/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
